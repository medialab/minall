{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This site contains the project documentation for the <code>minall</code> data enrichment workflow. The project's aim is to collect and update metadata about target Web Content.</p> <p><code>minall</code> relies on the Python tool and library <code>minet</code>, which this project's name references.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<p>The documentation follows the best practice for project documentation as described by Daniele Procida in the Di\u00e1taxis documentation framework and consists of four separate parts:</p> <ol> <li>Tutorials</li> <li>How-To Guides</li> <li>Reference</li> <li>Explanation</li> </ol> <p>Quickly find what you're looking for depending on your use case by looking at the different pages.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This project was developed as a response to research needs in the European project De Facto and with the help of members of the m\u00e9dialab at Sciences Po. In particular, the project depends on the excellent work of Guillaume Plique and other contributors to the m\u00e9dialab's tool <code>minet</code>.</p>"},{"location":"explanation/","title":"Explanation","text":"<p>This part of the project documentation focuses on an understanding-oriented approach. You'll get a chance to read about the background of the project, as well as reasoning about how it was implemented.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Give context and background on your library</li> <li>Explain why you created it</li> <li>Provide multiple examples and approaches of how   to work with it</li> <li>Help the reader make connections</li> <li>Avoid writing instructions or technical descriptions   here</li> </ul> <p>Example from https://realpython.com/python-project-documentation-with-mkdocs/</p>"},{"location":"how-to-guides/","title":"How-To Guides","text":"<p>This part of the project documentation focuses on a problem-oriented approach. You'll tackle common tasks that you might have, with the help of the code provided in this project.</p>"},{"location":"how-to-guides/#how-to-add-two-numbers","title":"How To Add Two Numbers?","text":"<p>You have two numbers and you need to add them together. You're in luck! The <code>calculator</code> package can help you get this done.</p> <p>Download the code from this GitHub repository and place the <code>calculator/</code> folder in the same directory as your Python script:</p> <pre><code>your_project/\n\u2502\n\u251c\u2500\u2500 calculator/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 calculations.py\n\u2502\n\u2514\u2500\u2500 your_script.py\n</code></pre> <p>Inside of <code>your_script.py</code> you can now import the <code>add()</code> function from the <code>calculator.calculations</code> module:</p> <pre><code># your_script.py\nfrom calculator.calculations import add\n</code></pre> <p>After you've imported the function, you can use it to add any two numbers that you need to add:</p> <pre><code># your_script.py\nfrom calculator.calculations import add\n\nprint(add(20, 22))  # OUTPUT: 42.0\n</code></pre> <p>You're now able to add any two numbers, and you'll always get a <code>float</code> as a result.</p> <p>Example from https://realpython.com/python-project-documentation-with-mkdocs/</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>This part of the project documentation focuses on a learning-oriented approach. You'll learn how to get started with the code in this project.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Help newcomers with getting started</li> <li>Teach readers about your library by making them   write code</li> <li>Inspire confidence through examples that work for   everyone, repeatably</li> <li>Give readers an immediate sense of achievement</li> <li>Show concrete examples, no abstractions</li> <li>Provide the minimum necessary explanation</li> <li>Avoid any distractions</li> </ul> <p>Example from https://realpython.com/python-project-documentation-with-mkdocs/</p>"},{"location":"reference/cli/","title":"cli","text":""},{"location":"reference/cli/#minall.cli","title":"<code>minall.cli</code>","text":"<p>CLI action to run minall workflow.</p> <p>Modules exported by this package:</p> <ul> <li><code>parse_args</code>: Parse command-line arguments.</li> <li><code>run</code>: Run the Minall class in the main module as a CLI tool.</li> </ul>"},{"location":"reference/cli/#minall.cli.parse_args","title":"<code>minall.cli.parse_args</code>","text":"<p>Helper functions for CLI action.</p> <p>This module contains the following helper functions for parsing command-line arguments:</p> <ul> <li><code>cli_args()</code> - Parse CLI arguments.</li> <li><code>dir_path(path_name)</code> - Create directory and necessary parent directories.</li> <li><code>file_path(path_name)</code> - Verify existence of given file.</li> <li><code>has_parent(path_name)</code> - Create necessary parent directories for file path.</li> </ul>"},{"location":"reference/cli/#minall.cli.parse_args.cli_args","title":"<code>cli_args()</code>","text":"<p>Function to call and parse command-line arguments.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of parsed command-line arguments.</p> Source code in <code>minall/cli/parse_args.py</code> <pre><code>def cli_args() -&gt; dict:\n    \"\"\"Function to call and parse command-line arguments.\n\n    Returns:\n        dict: Dictionary of parsed command-line arguments.\n    \"\"\"\n    parser = ArgumentParser(\n        add_help=True, prog=\"Minall\", formatter_class=RawDescriptionHelpFormatter\n    )\n    parser.add_argument(\n        \"--database\",\n        dest=\"database\",\n        required=False,\n        type=has_parent,\n        help=\"[Optional] Path to SQLite database. If not given, database written to memory.\",\n    )\n    parser.add_argument(\n        \"--config\",\n        dest=\"config\",\n        type=file_path,\n        required=False,\n        help=\"[Optional] Path to configuration file. If not given, environment variables are expected.\",\n    )\n    parser.add_argument(\n        \"--output-dir\",\n        dest=\"output_dir\",\n        type=dir_path,\n        required=True,\n        help=\"[Required] Path to directory in which a links and shared_content file will be written.\",\n    )\n    parser.add_argument(\n        \"--links\",\n        dest=\"links_file\",\n        type=file_path,\n        required=True,\n        help=\"[Required] Path to links file.\",\n    )\n    parser.add_argument(\n        \"--url-col\",\n        dest=\"url_col\",\n        type=str,\n        required=True,\n        help=\"[Required] Name of URL column in links file.\",\n    )\n    parser.add_argument(\n        \"--shared-content\",\n        dest=\"shared_content_file\",\n        type=file_path,\n        required=False,\n        help=\"[Optional] Path to shared_content file.\",\n    )\n    parser.add_argument(\n        \"--buzzsumo-only\",\n        dest=\"buzzsumo_only\",\n        default=False,\n        required=False,\n        action=\"store_true\",\n        help=\"[Optional] Flag indicating only Buzzsumo API will be called on links file.\",\n    )\n    args = parser.parse_args()\n    return args.__dict__\n</code></pre>"},{"location":"reference/cli/#minall.cli.parse_args.dir_path","title":"<code>dir_path(path_name)</code>","text":"<p>Function to convert argument to created directory.</p> <p>Parameters:</p> Name Type Description Default <code>path_name</code> <code>str</code> <p>Path to target directory.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to prepared directory.</p> Source code in <code>minall/cli/parse_args.py</code> <pre><code>def dir_path(path_name: str) -&gt; str:\n    \"\"\"Function to convert argument to created directory.\n\n    Args:\n        path_name (str): Path to target directory.\n\n    Returns:\n        str: Path to prepared directory.\n    \"\"\"\n    if Path(path_name).is_dir():\n        return path_name\n    else:\n        Path(path_name).mkdir(exist_ok=True)\n        [p.mkdir(exist_ok=True) for p in Path(path_name).parents]\n        return path_name\n</code></pre>"},{"location":"reference/cli/#minall.cli.parse_args.file_path","title":"<code>file_path(path_name)</code>","text":"<p>Function to convert argument to verified, found file path.</p> <p>Parameters:</p> Name Type Description Default <code>path_name</code> <code>str</code> <p>Path to data file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Data file not found at given path.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Verified path to data file.</p> Source code in <code>minall/cli/parse_args.py</code> <pre><code>def file_path(path_name: str) -&gt; str:\n    \"\"\"Function to convert argument to verified, found file path.\n\n    Args:\n        path_name (str): Path to data file.\n\n    Raises:\n        FileNotFoundError: Data file not found at given path.\n\n    Returns:\n        str: Verified path to data file.\n    \"\"\"\n    if Path(path_name).is_file():\n        return path_name\n    else:\n        raise FileNotFoundError(path_name)\n</code></pre>"},{"location":"reference/cli/#minall.cli.parse_args.has_parent","title":"<code>has_parent(path_name)</code>","text":"<p>Function to convert argument to file path with created parent directories.</p> <p>Parameters:</p> Name Type Description Default <code>path_name</code> <code>str</code> <p>Path to out-file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to out-file with created parent directories.</p> Source code in <code>minall/cli/parse_args.py</code> <pre><code>def has_parent(path_name: str) -&gt; str:\n    \"\"\"Function to convert argument to file path with created parent directories.\n\n    Args:\n        path_name (str): Path to out-file.\n\n    Returns:\n        str: Path to out-file with created parent directories.\n    \"\"\"\n    [p.mkdir(exist_ok=True) for p in Path(path_name).parents]\n    return path_name\n</code></pre>"},{"location":"reference/cli/#minall.cli.run","title":"<code>minall.cli.run</code>","text":"<p>CLI action for minall workflow.</p> <p>This module runs the minall workflow as a CLI tool.</p> <p>The module contains the following function:</p> <ul> <li><code>cli()</code> -</li> </ul>"},{"location":"reference/cli/#minall.cli.run.cli","title":"<code>cli()</code>","text":"<p>Run minall workflow from the command line.</p> Source code in <code>minall/cli/run.py</code> <pre><code>def cli():\n    \"\"\"Run minall workflow from the command line.\"\"\"\n\n    args = cli_args()\n\n    app = Minall(**args)\n\n    app.collect_and_coalesce()\n\n    app.export()\n</code></pre>"},{"location":"reference/enrichment/","title":"root","text":""},{"location":"reference/enrichment/#minall.enrichment","title":"<code>minall.enrichment</code>","text":"<p>Scripts to execute data collection.</p> <p>Modules exported by this package:</p> <ul> <li><code>enrichment</code>: Class that manages steps of data collection.</li> <li><code>utils</code>: Module that provides helper functions for enrichment.</li> </ul>"},{"location":"reference/enrichment/#minall.enrichment.enrichment","title":"<code>minall.enrichment.enrichment</code>","text":"<p>Class for data collection and coalescing.</p> <p>With the class <code>Enrichment</code>, this module manages the data collection process.</p> <p>The class contains the following methods:</p> <ul> <li><code>__init__(links_table, shared_content_table, keys)</code> -</li> </ul>"},{"location":"reference/enrichment/#minall.enrichment.enrichment.Enrichment","title":"<code>Enrichment</code>","text":"Source code in <code>minall/enrichment/enrichment.py</code> <pre><code>class Enrichment:\n    def __init__(\n        self,\n        links_table: BaseTable,\n        shared_content_table: BaseTable,\n        keys: APIKeys,\n    ) -&gt; None:\n        \"\"\"From given API keys and URL data set, filter URLs by domain and initialize data enrichment class.\n\n        Args:\n            links_table (BaseTable): BaseTable class instance of SQL table for URL dataset.\n            shared_content_table (BaseTable): BaseTable class instance of SQL table for shared content related to URLs in dataset.\n            keys (APIKeys): APIKeys class instance of minet API client configurations.\n        \"\"\"\n\n        self.links_table = links_table\n        self.shared_content_table = shared_content_table\n        self.keys = keys\n        self.filtered_links = FilteredLinks(self.links_table)\n\n    def buzzsumo(self):\n        \"\"\"For all URLs, collect data from Buzzsumo and coalesce in the database's 'links' table.\"\"\"\n\n        if self.keys.buzzsumo_token:\n            get_buzzsumo_data(\n                data=self.filtered_links.all_links,\n                token=self.keys.buzzsumo_token,\n                outfile=self.links_table.outfile,\n            )\n            self.links_table.coalesce(infile=self.links_table.outfile)\n\n    def scraper(self):\n        \"\"\"For select URLs, collect data via scraping and coalesce in the database's 'links' table.\"\"\"\n\n        # In multiple threads, scrape HTML data and write to a CSV file\n        get_article_text(\n            data=self.filtered_links.to_scrape, outfile=self.links_table.outfile\n        )\n        # Coalesce the results in the CSV File to the links table\n        self.links_table.coalesce(infile=self.links_table.outfile)\n\n    def other_social_media(self):\n        \"\"\"For select URLs, update the 'work_type' column in the database's 'links' table with the value 'SocialMediaPosting'.\"\"\"\n        # Assign default type to social media post\n        add_type_data(\n            data=self.filtered_links.other_social, outfile=self.links_table.outfile\n        )\n        # Coalesce the results in the CSV File to the links table\n        self.links_table.coalesce(infile=self.links_table.outfile)\n\n    def facebook(self):\n        \"\"\"For Facebook URLs, collect data from CrowdTangle and coalesce in the database's 'links' and 'shared_content' tables.\"\"\"\n        if self.keys.crowdtangle_token:\n            get_facebook_post_data(\n                data=self.filtered_links.facebook,\n                token=self.keys.crowdtangle_token,\n                rate_limit=self.keys.crowdtangle_rate_limit,\n                links_outfile=self.links_table.outfile,\n                shared_content_outfile=self.shared_content_table.outfile,\n            )\n            # Coalesce the results in the CSV File to the links table\n            self.links_table.coalesce(infile=self.links_table.outfile)\n            self.shared_content_table.coalesce(infile=self.shared_content_table.outfile)\n\n    def youtube(self):\n        \"\"\"For YouTube URLs, collect data from YouTube API and coalesce in the database's 'links' table.\"\"\"\n        if self.keys.youtube_key:\n            # In single thread, collect YouTube API data and write to a CSV file\n            get_youtube_data(\n                data=self.filtered_links.youtube,\n                keys=self.keys.youtube_key,\n                outfile=self.links_table.outfile,\n            )\n            # Coalesce the results in the CSV File to the links table\n            self.links_table.coalesce(infile=self.links_table.outfile)\n\n    def __call__(self, buzzsumo_only: bool):\n        executor = SQLiteWrapper(connection=self.links_table.connection)\n        # apply domain to all urls\n        for link in self.filtered_links.all_links:\n            query, domain = apply_domain(link)\n            if query and domain:\n                self.links_table.connection\n                executor(query=query)\n\n        if not buzzsumo_only:\n            if len(self.filtered_links.youtube) &gt; 0:\n                self.youtube()\n            if len(self.filtered_links.facebook) &gt; 0:\n                self.facebook()\n            if len(self.filtered_links.other_social) &gt; 0:\n                self.other_social_media()\n            if len(self.filtered_links.to_scrape) &gt; 0:\n                self.scraper()\n        self.buzzsumo()\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.enrichment.Enrichment.__init__","title":"<code>__init__(links_table, shared_content_table, keys)</code>","text":"<p>From given API keys and URL data set, filter URLs by domain and initialize data enrichment class.</p> <p>Parameters:</p> Name Type Description Default <code>links_table</code> <code>BaseTable</code> <p>BaseTable class instance of SQL table for URL dataset.</p> required <code>shared_content_table</code> <code>BaseTable</code> <p>BaseTable class instance of SQL table for shared content related to URLs in dataset.</p> required <code>keys</code> <code>APIKeys</code> <p>APIKeys class instance of minet API client configurations.</p> required Source code in <code>minall/enrichment/enrichment.py</code> <pre><code>def __init__(\n    self,\n    links_table: BaseTable,\n    shared_content_table: BaseTable,\n    keys: APIKeys,\n) -&gt; None:\n    \"\"\"From given API keys and URL data set, filter URLs by domain and initialize data enrichment class.\n\n    Args:\n        links_table (BaseTable): BaseTable class instance of SQL table for URL dataset.\n        shared_content_table (BaseTable): BaseTable class instance of SQL table for shared content related to URLs in dataset.\n        keys (APIKeys): APIKeys class instance of minet API client configurations.\n    \"\"\"\n\n    self.links_table = links_table\n    self.shared_content_table = shared_content_table\n    self.keys = keys\n    self.filtered_links = FilteredLinks(self.links_table)\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.enrichment.Enrichment.buzzsumo","title":"<code>buzzsumo()</code>","text":"<p>For all URLs, collect data from Buzzsumo and coalesce in the database's 'links' table.</p> Source code in <code>minall/enrichment/enrichment.py</code> <pre><code>def buzzsumo(self):\n    \"\"\"For all URLs, collect data from Buzzsumo and coalesce in the database's 'links' table.\"\"\"\n\n    if self.keys.buzzsumo_token:\n        get_buzzsumo_data(\n            data=self.filtered_links.all_links,\n            token=self.keys.buzzsumo_token,\n            outfile=self.links_table.outfile,\n        )\n        self.links_table.coalesce(infile=self.links_table.outfile)\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.enrichment.Enrichment.facebook","title":"<code>facebook()</code>","text":"<p>For Facebook URLs, collect data from CrowdTangle and coalesce in the database's 'links' and 'shared_content' tables.</p> Source code in <code>minall/enrichment/enrichment.py</code> <pre><code>def facebook(self):\n    \"\"\"For Facebook URLs, collect data from CrowdTangle and coalesce in the database's 'links' and 'shared_content' tables.\"\"\"\n    if self.keys.crowdtangle_token:\n        get_facebook_post_data(\n            data=self.filtered_links.facebook,\n            token=self.keys.crowdtangle_token,\n            rate_limit=self.keys.crowdtangle_rate_limit,\n            links_outfile=self.links_table.outfile,\n            shared_content_outfile=self.shared_content_table.outfile,\n        )\n        # Coalesce the results in the CSV File to the links table\n        self.links_table.coalesce(infile=self.links_table.outfile)\n        self.shared_content_table.coalesce(infile=self.shared_content_table.outfile)\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.enrichment.Enrichment.other_social_media","title":"<code>other_social_media()</code>","text":"<p>For select URLs, update the 'work_type' column in the database's 'links' table with the value 'SocialMediaPosting'.</p> Source code in <code>minall/enrichment/enrichment.py</code> <pre><code>def other_social_media(self):\n    \"\"\"For select URLs, update the 'work_type' column in the database's 'links' table with the value 'SocialMediaPosting'.\"\"\"\n    # Assign default type to social media post\n    add_type_data(\n        data=self.filtered_links.other_social, outfile=self.links_table.outfile\n    )\n    # Coalesce the results in the CSV File to the links table\n    self.links_table.coalesce(infile=self.links_table.outfile)\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.enrichment.Enrichment.scraper","title":"<code>scraper()</code>","text":"<p>For select URLs, collect data via scraping and coalesce in the database's 'links' table.</p> Source code in <code>minall/enrichment/enrichment.py</code> <pre><code>def scraper(self):\n    \"\"\"For select URLs, collect data via scraping and coalesce in the database's 'links' table.\"\"\"\n\n    # In multiple threads, scrape HTML data and write to a CSV file\n    get_article_text(\n        data=self.filtered_links.to_scrape, outfile=self.links_table.outfile\n    )\n    # Coalesce the results in the CSV File to the links table\n    self.links_table.coalesce(infile=self.links_table.outfile)\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.enrichment.Enrichment.youtube","title":"<code>youtube()</code>","text":"<p>For YouTube URLs, collect data from YouTube API and coalesce in the database's 'links' table.</p> Source code in <code>minall/enrichment/enrichment.py</code> <pre><code>def youtube(self):\n    \"\"\"For YouTube URLs, collect data from YouTube API and coalesce in the database's 'links' table.\"\"\"\n    if self.keys.youtube_key:\n        # In single thread, collect YouTube API data and write to a CSV file\n        get_youtube_data(\n            data=self.filtered_links.youtube,\n            keys=self.keys.youtube_key,\n            outfile=self.links_table.outfile,\n        )\n        # Coalesce the results in the CSV File to the links table\n        self.links_table.coalesce(infile=self.links_table.outfile)\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.utils","title":"<code>minall.enrichment.utils</code>","text":"<p>Functions for data collection.</p> <p>This module provides the following class and functions:</p> <ul> <li><code>get_domain(url)</code> - Parse domain from URL string.</li> <li><code>apply_domain(url)</code> - Generate SQL query to insert domain into table.</li> <li><code>FilteredLinks(table)</code> - From SQL table, select subsets of URLs based on domain name.</li> </ul>"},{"location":"reference/enrichment/#minall.enrichment.utils.FilteredLinks","title":"<code>FilteredLinks</code>","text":"<p>Selects all URLs from SQL table and returns subsets.</p> Source code in <code>minall/enrichment/utils.py</code> <pre><code>class FilteredLinks:\n    \"\"\"Selects all URLs from SQL table and returns subsets.\"\"\"\n\n    def __init__(self, table: BaseTable) -&gt; None:\n        \"\"\"Select and store all URLs from a target SQL table.\n\n        Args:\n            table (BaseTable): Target SQL table.\n        \"\"\"\n        cursor = table.connection.cursor()\n        self.all_links = [\n            row[0]\n            for row in cursor.execute(\n                f\"SELECT url FROM {table.table.table_name}\"\n            ).fetchall()\n        ]\n\n    @property\n    def youtube(self) -&gt; List[str]:\n        \"\"\"List of URLs from YouTube.\n\n        Returns:\n            List[str]: List of URL strings.\n        \"\"\"\n        return [url for url in self.all_links if is_youtube_url(url=url)]\n\n    @property\n    def facebook(self) -&gt; List[str]:\n        \"\"\"List of URLs from Facebook.\n\n        Returns:\n            List[str]: List of URL strings.\n        \"\"\"\n        return [url for url in self.all_links if is_facebook_url(url=url)]\n\n    @property\n    def other_social(self) -&gt; List[str]:\n        \"\"\"List of URLs from social media platforms.\n\n        Returns:\n            List[str]: List of URL strings.\n        \"\"\"\n        return [\n            url\n            for url in self.all_links\n            if get_domain(url=url)\n            in [\n                \"facebook.com\",\n                \"youtube.com\",\n                \"tiktok.com\",\n                \"instagram.com\",\n                \"twitter.com\",\n                \"snapchat.com\",\n            ]\n        ]\n\n    @property\n    def to_scrape(self) -&gt; List[str]:\n        \"\"\"List of URLs not from social media platforms.\n\n        Returns:\n            List[str]: List of URL strings.\n        \"\"\"\n        return [\n            url\n            for url in self.all_links\n            if get_domain(url=url)\n            not in [\n                \"facebook.com\",\n                \"youtube.com\",\n                \"tiktok.com\",\n                \"instagram.com\",\n                \"twitter.com\",\n                \"snapchat.com\",\n            ]\n        ]\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.utils.FilteredLinks.facebook","title":"<code>facebook: List[str]</code>  <code>property</code>","text":"<p>List of URLs from Facebook.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of URL strings.</p>"},{"location":"reference/enrichment/#minall.enrichment.utils.FilteredLinks.other_social","title":"<code>other_social: List[str]</code>  <code>property</code>","text":"<p>List of URLs from social media platforms.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of URL strings.</p>"},{"location":"reference/enrichment/#minall.enrichment.utils.FilteredLinks.to_scrape","title":"<code>to_scrape: List[str]</code>  <code>property</code>","text":"<p>List of URLs not from social media platforms.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of URL strings.</p>"},{"location":"reference/enrichment/#minall.enrichment.utils.FilteredLinks.youtube","title":"<code>youtube: List[str]</code>  <code>property</code>","text":"<p>List of URLs from YouTube.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of URL strings.</p>"},{"location":"reference/enrichment/#minall.enrichment.utils.FilteredLinks.__init__","title":"<code>__init__(table)</code>","text":"<p>Select and store all URLs from a target SQL table.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>BaseTable</code> <p>Target SQL table.</p> required Source code in <code>minall/enrichment/utils.py</code> <pre><code>def __init__(self, table: BaseTable) -&gt; None:\n    \"\"\"Select and store all URLs from a target SQL table.\n\n    Args:\n        table (BaseTable): Target SQL table.\n    \"\"\"\n    cursor = table.connection.cursor()\n    self.all_links = [\n        row[0]\n        for row in cursor.execute(\n            f\"SELECT url FROM {table.table.table_name}\"\n        ).fetchall()\n    ]\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.utils.apply_domain","title":"<code>apply_domain(url)</code>","text":"<p>Compose SQL query to update the domain column of a URL's row in the 'links' SQLite table.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; apply_domain(url=\"https://www.youtube.com/channel/MkDocs\")\n(\"UPDATE links SET domain = 'youtube.com' WHERE url = 'https://www.youtube.com/channel/MkDocs'\", 'youtube.com')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL string.</p> required <p>Returns:</p> Type Description <code>Tuple[str | None, str | None]</code> <p>Tuple[str | None, str | None]: If domain was parsed, a tuple containing the SQL query and domain name.</p> Source code in <code>minall/enrichment/utils.py</code> <pre><code>def apply_domain(url: str) -&gt; Tuple[str | None, str | None]:\n    \"\"\"Compose SQL query to update the domain column of a URL's row in the 'links' SQLite table.\n\n    Examples:\n        &gt;&gt;&gt; apply_domain(url=\"https://www.youtube.com/channel/MkDocs\")\n        (\"UPDATE links SET domain = 'youtube.com' WHERE url = 'https://www.youtube.com/channel/MkDocs'\", 'youtube.com')\n\n    Args:\n        url (str): URL string.\n\n    Returns:\n        Tuple[str | None, str | None]: If domain was parsed, a tuple containing the SQL query and domain name.\n    \"\"\"\n\n    query = None\n    domain = get_domain(url)\n    if domain:\n        query = f\"UPDATE {LinksConstants.table_name} SET domain = '{domain}' WHERE {LinksConstants.primary_key} = '{url}'\"\n    return query, domain\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.utils.get_domain","title":"<code>get_domain(url)</code>","text":"<p>Parse the domain name of a given URL string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_domain(url=\"https://www.youtube.com/channel/MkDocs\")\n'youtube.com'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL string.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: If successfully parsed, domain name.</p> Source code in <code>minall/enrichment/utils.py</code> <pre><code>def get_domain(url: str) -&gt; str | None:\n    \"\"\"Parse the domain name of a given URL string.\n\n    Examples:\n        &gt;&gt;&gt; get_domain(url=\"https://www.youtube.com/channel/MkDocs\")\n        'youtube.com'\n\n    Args:\n        url (str): URL string.\n\n    Returns:\n        str | None: If successfully parsed, domain name.\n    \"\"\"\n\n    domain_name = ural.get_domain_name(url)\n    if domain_name in YOUTUBE_DOMAINS:\n        domain_name = \"youtube.com\"\n    return domain_name\n</code></pre>"},{"location":"reference/root/","title":"Root of <code>minall</code>","text":""},{"location":"reference/root/#minall.main","title":"<code>minall.main</code>","text":"<p>Minall enrichment workflow.</p> <p>With the class <code>Minall</code>, this module manages the entire workflow.</p> <p>The class contains the following methods:</p> <ul> <li><code>__init__(database, config, output_dir, links_file, url_col, shared_content_file, buzzsumo_only)</code> - Intialize SQLite database and out-file paths.</li> <li><code>collect_and_coalesce()</code> - Collect new data and coalesce with existing data in relevant SQL tables.</li> <li><code>export()</code> - Write enriched SQL tables to CSV out-files.</li> </ul>"},{"location":"reference/root/#minall.main.Minall","title":"<code>Minall</code>","text":"<p>Class to store variables and execute steps of enrichment.</p> Source code in <code>minall/main.py</code> <pre><code>class Minall:\n    \"\"\"Class to store variables and execute steps of enrichment.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None,\n        config: str | dict | None,\n        output_dir: str,\n        links_file: str,\n        url_col: str,\n        shared_content_file: str | None = None,\n        buzzsumo_only: bool = False,\n    ) -&gt; None:\n        \"\"\"Intialize SQLite database and out-file paths.\n\n        Args:\n            database (str | None): Path name to SQLite database. If None, creates database in memory.\n            config (str | dict | None): Credentials for API keys.\n            output_dir (str): Path name to directory for enriched CSV files.\n            links_file (str): Path name to in-file for URLs.\n            url_col (str): Name of URL column in URLs file.\n            shared_content_file (str | None): Path name to CSV file of shared content related to URLs.\n            buzzsumo_only (bool, optional): Whether to only run Buzzsumo enrichment. Defaults to False.\n        \"\"\"\n\n        # Connect to the SQLite database\n        self.connection = connect_to_database(database=database)\n\n        # Parse API keys from config file / dict\n        self.keys = APIKeys(config=config)\n\n        # Store Buzzsumo-only flag\n        self.buzzsumo_only = buzzsumo_only\n\n        # Set paths to output directory and out-files\n        [p.mkdir(exist_ok=True) for p in Path(output_dir).parents]\n        self.output_dir = Path(output_dir)\n        self.links_file = self.output_dir.joinpath(\"links.csv\")\n        self.shared_contents_file = self.output_dir.joinpath(\"shared_content.csv\")\n\n        # Input original data into the database\n        self.links_table = BaseTable(\n            sqlite_connection=self.connection,\n            infile=links_file,\n            outfile=self.links_file,\n            table=LinksConstants(),\n            url_col=url_col,\n        )\n\n        self.shared_content_table = BaseTable(\n            sqlite_connection=self.connection,\n            infile=shared_content_file,\n            outfile=self.shared_contents_file,\n            table=ShareContentConstants(),\n        )\n\n    def collect_and_coalesce(self):\n        \"\"\"Collect new data and coalesce with existing data in relevant SQL tables.\"\"\"\n        enricher = Enrichment(\n            links_table=self.links_table,\n            shared_content_table=self.shared_content_table,\n            keys=self.keys,\n        )\n        enricher(buzzsumo_only=self.buzzsumo_only)\n\n    def export(self) -&gt; Tuple[Path, Path]:\n        \"\"\"Write enriched SQL tables to CSV out-files.\n\n        Returns:\n            Tuple[Path, Path]: Paths to links and shared content CSV files.\n        \"\"\"\n        self.links_table.export()\n        self.shared_content_table.export()\n        return self.links_file, self.shared_contents_file\n</code></pre>"},{"location":"reference/root/#minall.main.Minall.__init__","title":"<code>__init__(database, config, output_dir, links_file, url_col, shared_content_file=None, buzzsumo_only=False)</code>","text":"<p>Intialize SQLite database and out-file paths.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>str | None</code> <p>Path name to SQLite database. If None, creates database in memory.</p> required <code>config</code> <code>str | dict | None</code> <p>Credentials for API keys.</p> required <code>output_dir</code> <code>str</code> <p>Path name to directory for enriched CSV files.</p> required <code>links_file</code> <code>str</code> <p>Path name to in-file for URLs.</p> required <code>url_col</code> <code>str</code> <p>Name of URL column in URLs file.</p> required <code>shared_content_file</code> <code>str | None</code> <p>Path name to CSV file of shared content related to URLs.</p> <code>None</code> <code>buzzsumo_only</code> <code>bool</code> <p>Whether to only run Buzzsumo enrichment. Defaults to False.</p> <code>False</code> Source code in <code>minall/main.py</code> <pre><code>def __init__(\n    self,\n    database: str | None,\n    config: str | dict | None,\n    output_dir: str,\n    links_file: str,\n    url_col: str,\n    shared_content_file: str | None = None,\n    buzzsumo_only: bool = False,\n) -&gt; None:\n    \"\"\"Intialize SQLite database and out-file paths.\n\n    Args:\n        database (str | None): Path name to SQLite database. If None, creates database in memory.\n        config (str | dict | None): Credentials for API keys.\n        output_dir (str): Path name to directory for enriched CSV files.\n        links_file (str): Path name to in-file for URLs.\n        url_col (str): Name of URL column in URLs file.\n        shared_content_file (str | None): Path name to CSV file of shared content related to URLs.\n        buzzsumo_only (bool, optional): Whether to only run Buzzsumo enrichment. Defaults to False.\n    \"\"\"\n\n    # Connect to the SQLite database\n    self.connection = connect_to_database(database=database)\n\n    # Parse API keys from config file / dict\n    self.keys = APIKeys(config=config)\n\n    # Store Buzzsumo-only flag\n    self.buzzsumo_only = buzzsumo_only\n\n    # Set paths to output directory and out-files\n    [p.mkdir(exist_ok=True) for p in Path(output_dir).parents]\n    self.output_dir = Path(output_dir)\n    self.links_file = self.output_dir.joinpath(\"links.csv\")\n    self.shared_contents_file = self.output_dir.joinpath(\"shared_content.csv\")\n\n    # Input original data into the database\n    self.links_table = BaseTable(\n        sqlite_connection=self.connection,\n        infile=links_file,\n        outfile=self.links_file,\n        table=LinksConstants(),\n        url_col=url_col,\n    )\n\n    self.shared_content_table = BaseTable(\n        sqlite_connection=self.connection,\n        infile=shared_content_file,\n        outfile=self.shared_contents_file,\n        table=ShareContentConstants(),\n    )\n</code></pre>"},{"location":"reference/root/#minall.main.Minall.collect_and_coalesce","title":"<code>collect_and_coalesce()</code>","text":"<p>Collect new data and coalesce with existing data in relevant SQL tables.</p> Source code in <code>minall/main.py</code> <pre><code>def collect_and_coalesce(self):\n    \"\"\"Collect new data and coalesce with existing data in relevant SQL tables.\"\"\"\n    enricher = Enrichment(\n        links_table=self.links_table,\n        shared_content_table=self.shared_content_table,\n        keys=self.keys,\n    )\n    enricher(buzzsumo_only=self.buzzsumo_only)\n</code></pre>"},{"location":"reference/root/#minall.main.Minall.export","title":"<code>export()</code>","text":"<p>Write enriched SQL tables to CSV out-files.</p> <p>Returns:</p> Type Description <code>Tuple[Path, Path]</code> <p>Tuple[Path, Path]: Paths to links and shared content CSV files.</p> Source code in <code>minall/main.py</code> <pre><code>def export(self) -&gt; Tuple[Path, Path]:\n    \"\"\"Write enriched SQL tables to CSV out-files.\n\n    Returns:\n        Tuple[Path, Path]: Paths to links and shared content CSV files.\n    \"\"\"\n    self.links_table.export()\n    self.shared_content_table.export()\n    return self.links_file, self.shared_contents_file\n</code></pre>"},{"location":"reference/root/#minall.exceptions","title":"<code>minall.exceptions</code>","text":"<p>Tools to validate CSV file used for creating SQLite table.</p> <p>This module contains a function and exceptions to manage the process of validating a CSV file given as the URL dataset for the enrichment process. The function is called when one of the SQLite's tables are being created. The module contains the following function and exceptions:</p> <ul> <li><code>check_csv_headers(table_name, infile_path, url_col)</code> - Parse columns in CSV file and raise exception if invalid.</li> <li><code>NoCSVHeaders</code> - The CSV does not have headers.</li> <li><code>NoURLColumn</code> - When building the 'links' table, the declared URL column is not in the CSV file.</li> <li><code>NoPrimaryKeyColumns</code> - When building the 'shared_content' table, either the 'post_url' column or the 'content_url' column are missing from the CSV file.</li> </ul> <p>When creating the 'links' table, the input CSV file must have a column for URLs; the URLs must be cleaned and/or ready to serve as the source for the data collection. The name of the URL column can vary and must be declared.</p> <p>When creating the 'shared_content' table, the column names are not modifiable. The CSV must have the columns 'post_url' and 'content_url;' the former relates to a URL in the 'links' table, and the latter incidates a URL for content embedded in the Web Content of the former.</p>"},{"location":"reference/root/#minall.exceptions.check_csv_headers","title":"<code>check_csv_headers(table_name, infile_path, url_col)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>description</p> required <code>infile_path</code> <code>str</code> <p>description</p> required <code>url_col</code> <code>str | None</code> <p>description</p> required <p>Raises:</p> Type Description <code>NoCSVHeaders</code> <p>description</p> <code>NoURLColumn</code> <p>description</p> <code>NoPrimaryKeyColumns</code> <p>description</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: description</p> Source code in <code>minall/exceptions.py</code> <pre><code>def check_csv_headers(\n    table_name: str, infile_path: str, url_col: str | None\n) -&gt; List[str]:\n    \"\"\"_summary_\n\n    Args:\n        table_name (str): _description_\n        infile_path (str): _description_\n        url_col (str | None): _description_\n\n    Raises:\n        NoCSVHeaders: _description_\n        NoURLColumn: _description_\n        NoPrimaryKeyColumns: _description_\n\n    Returns:\n        List[str]: _description_\n    \"\"\"\n    with casanova.reader(infile_path) as reader:\n        columns = reader.fieldnames\n\n    if not isinstance(columns, List):\n        raise NoCSVHeaders()\n\n    if table_name == \"links\":\n        if url_col not in columns:\n            raise NoURLColumn(str(url_col))\n\n    elif table_name == \"shared_content\":\n        if \"post_url\" not in columns:\n            raise NoPrimaryKeyColumns(\"post_url\")\n        if \"content_url\" not in columns:\n            raise NoPrimaryKeyColumns(\"content_url\")\n    return columns\n</code></pre>"},{"location":"reference/tables/","title":"tables","text":"<p>With SQLite, the module <code>minall/tables</code> manages the data during the enrichment process, from the data input at the start to the updated version exported at the end. The process relies on the following two tables:</p> <ol> <li> <p>The <code>links</code> table, which is the backbone of the enrichment, stores the target URLs and their enriched metadata.</p> </li> <li> <p>The <code>shared_content</code> table, which is optional, stores URLs pointing to content shared via the target URLs' content.</p> </li> </ol> <p>As illustrated in the figure below, the two tables are related. The target URL (<code>url</code>) in the <code>links</code> table refers to the <code>post_url</code> in the <code>shared_content</code> table. A target URL (<code>url</code>) in the <code>links</code> table can share 0 or more items. Depending on the URLs dataset, it could be the case that no entities in the <code>links</code> table have shared any content. All entities in the <code>shared_content</code> must relate to at least one entity in the <code>links</code> table. Content in the <code>shared_content</code> table can have been shared by 1 or more URLs in the <code>links</code> table.</p> <pre><code>erDiagram\n    LINKS }|--o{ SHARED_CONTENT : shares\n    LINKS {\n        text url PK\n        text domain\n        text work_type\n        text duration\n        text identifier\n        text date_published\n        text date_modified\n        text country_of_origin\n        text abstract\n        text keywords\n        text title\n        text text\n        text hashtags\n        text creator_type\n        text creator_date_created\n        text creator_identifier\n        integer creator_facebook_follow\n        integer creator_facebook_subscribe\n        integer creator_twitter_follow\n        integer creator_youtube_subscribe\n        integer creator_create_video\n        text creator_name\n        text creator_url\n        integer facebook_comment\n        integer facebook_like\n        integer facebook_share\n        integer pinterest_share\n        integer twitter_share\n        integer tiktok_share\n        integer tiktok_comment\n        integer reddit_engagement\n        integer youtube_watch\n        integer youtube_comment\n        integer youtube_like\n        integer youtube_favorite\n        integer youtube_subscribe\n        integer create_video\n    }\n    SHARED_CONTENT {\n        text post_url PK\n        text content_url PK\n        text media_type\n        integer height\n        integer width\n    }</code></pre>"},{"location":"reference/tables/#minall.tables","title":"<code>minall.tables</code>","text":""},{"location":"reference/tables/#minall.tables.links","title":"<code>minall.tables.links</code>","text":""},{"location":"reference/tables/#minall.tables.links.constants","title":"<code>minall.tables.links.constants</code>","text":""},{"location":"reference/tables/#minall.tables.links.constants.LinksConstants","title":"<code>LinksConstants</code>  <code>dataclass</code>","text":"<p>Dataclass to manage 'links' table.</p> <p>This dataclass manages the 'links' table's required column names and their data types. Being a dataclass, however, the instance of the class can also be subsequently modified to include other column names (and their data types) according to the input data.</p> <p>For example, if the input dataset's target URL column has a name other than 'url,' such as the name 'cleaned_urls,' this dataclass's <code>dtypes</code> and <code>col_names</code> attributes can be modified to preserve the data file's additional column names. However, the column 'url' must indicate the target URLs. If the input dataset does not have a 'url' column, one will be created. If it already has a 'url' column, that will be parsed and treated as the target URL column.</p> <p>Attributes:</p> Name Type Description <code>table_name</code> <code>str</code> <p>Name of the table. Default = \"links\".</p> <code>primary_key</code> <code>str</code> <p>Text string of primary key. Default = \"url\".</p> <code>pk_list</code> <code>list</code> <p>List of primary key columns. Default = [\"url\"]</p> <code>dtypes</code> <code>dict</code> <p>Key-value pairs of column names and SQLite data type descriptions.</p> <code>col_names</code> <code>list</code> <p>List of column names.</p> Source code in <code>minall/tables/links/constants.py</code> <pre><code>@dataclass\nclass LinksConstants:\n    \"\"\"Dataclass to manage 'links' table.\n\n    This dataclass manages the 'links' table's required column names and their data types. Being a dataclass, however, the instance of the class can also be subsequently modified to include other column names (and their data types) according to the input data.\n\n    For example, if the input dataset's target URL column has a name other than 'url,' such as the name 'cleaned_urls,' this dataclass's `dtypes` and `col_names` attributes can be modified to preserve the data file's additional column names. However, the column 'url' must indicate the target URLs. If the input dataset does not have a 'url' column, one will be created. If it already has a 'url' column, that will be parsed and treated as the target URL column.\n\n    Attributes:\n        table_name (str): Name of the table. Default = \"links\".\n        primary_key (str): Text string of primary key. Default = \"url\".\n        pk_list (list): List of primary key columns. Default = [\"url\"]\n        dtypes (dict): Key-value pairs of column names and SQLite data type descriptions.\n        col_names (list): List of column names.\n    \"\"\"\n\n    table_name: str = \"links\"\n    primary_key: str = \"url\"\n    pk_list = [\"url\"]\n    dtypes = {\n        \"url\": \"TEXT\",\n        \"domain\": \"TEXT\",\n        \"work_type\": \"TEXT\",\n        \"duration\": \"TEXT\",\n        \"identifier\": \"TEXT\",\n        \"date_published\": \"TEXT\",\n        \"date_modified\": \"TEXT\",\n        \"country_of_origin\": \"TEXT\",\n        \"abstract\": \"TEXT\",\n        \"keywords\": \"TEXT\",\n        \"title\": \"TEXT\",\n        \"text\": \"TEXT\",\n        \"hashtags\": \"TEXT\",\n        \"creator_type\": \"TEXT\",\n        \"creator_date_created\": \"TEXT\",\n        \"creator_location_created\": \"TEXT\",\n        \"creator_identifier\": \"TEXT\",\n        \"creator_facebook_follow\": \"INTEGER\",\n        \"creator_facebook_subscribe\": \"INTEGER\",\n        \"creator_twitter_follow\": \"INTEGER\",\n        \"creator_youtube_subscribe\": \"INTEGER\",\n        \"creator_create_video\": \"INTEGER\",\n        \"creator_name\": \"TEXT\",\n        \"creator_url\": \"TEXT\",\n        \"facebook_comment\": \"INTEGER\",\n        \"facebook_like\": \"INTEGER\",\n        \"facebook_share\": \"INTEGER\",\n        \"pinterest_share\": \"INTEGER\",\n        \"twitter_share\": \"INTEGER\",\n        \"tiktok_share\": \"INTEGER\",\n        \"tiktok_comment\": \"INTEGER\",\n        \"reddit_engagement\": \"INTEGER\",\n        \"youtube_watch\": \"INTEGER\",\n        \"youtube_comment\": \"INTEGER\",\n        \"youtube_like\": \"INTEGER\",\n        \"youtube_favorite\": \"INTEGER\",\n        \"youtube_subscribe\": \"INTEGER\",\n        \"create_video\": \"INTEGER\",\n    }\n    col_names = dtypes.keys()\n</code></pre>"},{"location":"reference/tables/#minall.tables.shared_content","title":"<code>minall.tables.shared_content</code>","text":""},{"location":"reference/tables/#minall.tables.shared_content.constants","title":"<code>minall.tables.shared_content.constants</code>","text":""},{"location":"reference/tables/#minall.tables.shared_content.constants.ShareContentConstants","title":"<code>ShareContentConstants</code>  <code>dataclass</code>","text":"<p>Dataclass to manage 'shared_content' table.</p> <p>This dataclass manages the 'shared_content' table's required column names and their data types. Being a dataclass, however, the instance of the class can also be subsequently modified to include other column names (and their data types) according to the input data. The 'shared_content' table is meant to relate to the 'links' table, wherein the former's 'post_url' column refers to the latter's 'url' column.</p> <p>Contrary to the 'links' table, whose primary key column can be derived from any declared target URL column in the input data, the 'shared_content' table requires the input data has the two columns that jointly compose its primary key, 'post_url' and 'content_url.'</p> <p>Attributes:</p> Name Type Description <code>table_name</code> <code>str</code> <p>Name of the table. Default = \"shared_content\".</p> <code>primary_key</code> <code>str</code> <p>Text string of composite primary key. Default = \"post_url,content_url\".</p> <code>pk_list</code> <code>list</code> <p>List of comosite primary key columns. Default = [\"post_url\", \"content_url]</p> <code>dtypes</code> <code>dict</code> <p>Key-value pairs of column names and SQLite data type descriptions.</p> <code>col_names</code> <code>list</code> <p>List of column names.</p> Source code in <code>minall/tables/shared_content/constants.py</code> <pre><code>@dataclass\nclass ShareContentConstants:\n    \"\"\"Dataclass to manage 'shared_content' table.\n\n    This dataclass manages the 'shared_content' table's required column names and their data types. Being a dataclass, however, the instance of the class can also be subsequently modified to include other column names (and their data types) according to the input data. The 'shared_content' table is meant to relate to the 'links' table, wherein the former's 'post_url' column refers to the latter's 'url' column.\n\n    Contrary to the 'links' table, whose primary key column can be derived from any declared target URL column in the input data, the 'shared_content' table requires the input data has the two columns that jointly compose its primary key, 'post_url' and 'content_url.'\n\n    Attributes:\n        table_name (str): Name of the table. Default = \"shared_content\".\n        primary_key (str): Text string of composite primary key. Default = \"post_url,content_url\".\n        pk_list (list): List of comosite primary key columns. Default = [\"post_url\", \"content_url]\n        dtypes (dict): Key-value pairs of column names and SQLite data type descriptions.\n        col_names (list): List of column names.\n    \"\"\"\n\n    table_name = \"shared_content\"\n    primary_key = \"post_url,content_url\"\n    pk_list = [\"post_url\", \"content_url\"]\n    dtypes = {\n        \"post_url\": f\"TEXT REFERENCES {LinksConstants.table_name}(url) ON UPDATE CASCADE\",\n        \"media_type\": \"TEXT\",\n        \"content_url\": \"TEXT\",\n        \"height\": \"INTEGER\",\n        \"width\": \"INTEGER\",\n    }\n    col_names = dtypes.keys()\n</code></pre>"},{"location":"reference/tables/#minall.tables.base","title":"<code>minall.tables.base</code>","text":""},{"location":"reference/tables/#minall.tables.utils","title":"<code>minall.tables.utils</code>","text":""},{"location":"reference/utils/","title":"utils","text":""},{"location":"reference/utils/#minall.utils","title":"<code>minall.utils</code>","text":"<p>Scripts to manage general functions of workflow.</p> <p>Modules exported by this package:</p> <ul> <li><code>database</code>: Class and function to connect to SQLite database.</li> <li><code>parse_config</code>: Class for managing minet API key credentials.</li> <li><code>progress_bar</code>: Context that generates rich progress bar.</li> </ul>"},{"location":"reference/utils/#minall.utils.database","title":"<code>minall.utils.database</code>","text":"<p>Utilities to manage SQLite database connection.</p> <p>The module contains the following function and class:</p> <ul> <li><code>connect_to_database(database)</code> - If provided with path, connects to embedded SQLite database; otherwise, connects to in-memory SQLite database.</li> <li><code>SQLiteWrapper(connection)</code> - Stores connection and cursor, executes queries.</li> </ul>"},{"location":"reference/utils/#minall.utils.database.SQLiteWrapper","title":"<code>SQLiteWrapper</code>","text":"<p>Class to store SQLite database connection and execute SQL queries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n&gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n&gt;&gt;&gt; wrapper.select(\"select * from test\")\n[]\n</code></pre> Source code in <code>minall/utils/database.py</code> <pre><code>class SQLiteWrapper:\n    \"\"\"Class to store SQLite database connection and execute SQL queries.\n\n    Examples:\n        &gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n        &gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n        &gt;&gt;&gt; wrapper.select(\"select * from test\")\n        []\n\n    \"\"\"\n\n    def __init__(self, connection: Connection) -&gt; None:\n        \"\"\"Store database connection and create cursor.\n\n        Examples:\n            &gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n            &gt;&gt;&gt; type(wrapper.cursor)\n            &lt;class 'sqlite3.Cursor'&gt;\n\n        Args:\n            connection (Connection): Connection to SQLite database.\n        \"\"\"\n        self.connection = connection\n        self.cursor = self.connection.cursor()\n\n    def __call__(self, query: str, values: List[Tuple] | None = None) -&gt; None:\n        \"\"\"Execute and commit SQL query.\n\n        Examples:\n            &gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n            &gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n            &gt;&gt;&gt; wrapper.select(\"select * from test\")\n            []\n\n        Args:\n            query (str): Query string, can contain SQL place holders for values (?).\n            values (list[tuple] | None, optional): Values to be included in query. Defaults to None.\n\n        Raises:\n            Exception: `sqlite3` Exception caused either by falling to execute query with cursor or by failing to commit changes to connected database.\n        \"\"\"\n        try:\n            if values:\n                self.cursor.execute(query, values)\n            else:\n                self.cursor.execute(query)\n            self.connection.commit()\n        except Exception as e:\n            print(\"\\n\", query, \"\\n\")\n            print(values)\n            raise e\n\n    def select(self, query: str) -&gt; List:\n        \"\"\"Return selection from SQLite database.\n\n        Examples:\n            &gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n            &gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n            &gt;&gt;&gt; wrapper.select(\"select * from test\")\n            []\n\n        Args:\n            query (str): SQL select query.\n\n        Raises:\n            Exception: `sqlite3` Exception caused either by falling to execute query with cursor or by failing to commit changes to connected database.\n\n        Returns:\n            List: Array of results from SQL query.\n        \"\"\"\n        try:\n            response = self.cursor.execute(query)\n            self.connection.commit()\n        except Exception as e:\n            print(\"\\n\", query, \"\\n\")\n            raise e\n        else:\n            return response.fetchall()\n</code></pre>"},{"location":"reference/utils/#minall.utils.database.SQLiteWrapper.__call__","title":"<code>__call__(query, values=None)</code>","text":"<p>Execute and commit SQL query.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n&gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n&gt;&gt;&gt; wrapper.select(\"select * from test\")\n[]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Query string, can contain SQL place holders for values (?).</p> required <code>values</code> <code>list[tuple] | None</code> <p>Values to be included in query. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p><code>sqlite3</code> Exception caused either by falling to execute query with cursor or by failing to commit changes to connected database.</p> Source code in <code>minall/utils/database.py</code> <pre><code>def __call__(self, query: str, values: List[Tuple] | None = None) -&gt; None:\n    \"\"\"Execute and commit SQL query.\n\n    Examples:\n        &gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n        &gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n        &gt;&gt;&gt; wrapper.select(\"select * from test\")\n        []\n\n    Args:\n        query (str): Query string, can contain SQL place holders for values (?).\n        values (list[tuple] | None, optional): Values to be included in query. Defaults to None.\n\n    Raises:\n        Exception: `sqlite3` Exception caused either by falling to execute query with cursor or by failing to commit changes to connected database.\n    \"\"\"\n    try:\n        if values:\n            self.cursor.execute(query, values)\n        else:\n            self.cursor.execute(query)\n        self.connection.commit()\n    except Exception as e:\n        print(\"\\n\", query, \"\\n\")\n        print(values)\n        raise e\n</code></pre>"},{"location":"reference/utils/#minall.utils.database.SQLiteWrapper.__init__","title":"<code>__init__(connection)</code>","text":"<p>Store database connection and create cursor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n&gt;&gt;&gt; type(wrapper.cursor)\n&lt;class 'sqlite3.Cursor'&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>Connection to SQLite database.</p> required Source code in <code>minall/utils/database.py</code> <pre><code>def __init__(self, connection: Connection) -&gt; None:\n    \"\"\"Store database connection and create cursor.\n\n    Examples:\n        &gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n        &gt;&gt;&gt; type(wrapper.cursor)\n        &lt;class 'sqlite3.Cursor'&gt;\n\n    Args:\n        connection (Connection): Connection to SQLite database.\n    \"\"\"\n    self.connection = connection\n    self.cursor = self.connection.cursor()\n</code></pre>"},{"location":"reference/utils/#minall.utils.database.SQLiteWrapper.select","title":"<code>select(query)</code>","text":"<p>Return selection from SQLite database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n&gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n&gt;&gt;&gt; wrapper.select(\"select * from test\")\n[]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>SQL select query.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p><code>sqlite3</code> Exception caused either by falling to execute query with cursor or by failing to commit changes to connected database.</p> <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>Array of results from SQL query.</p> Source code in <code>minall/utils/database.py</code> <pre><code>def select(self, query: str) -&gt; List:\n    \"\"\"Return selection from SQLite database.\n\n    Examples:\n        &gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n        &gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n        &gt;&gt;&gt; wrapper.select(\"select * from test\")\n        []\n\n    Args:\n        query (str): SQL select query.\n\n    Raises:\n        Exception: `sqlite3` Exception caused either by falling to execute query with cursor or by failing to commit changes to connected database.\n\n    Returns:\n        List: Array of results from SQL query.\n    \"\"\"\n    try:\n        response = self.cursor.execute(query)\n        self.connection.commit()\n    except Exception as e:\n        print(\"\\n\", query, \"\\n\")\n        raise e\n    else:\n        return response.fetchall()\n</code></pre>"},{"location":"reference/utils/#minall.utils.database.connect_to_database","title":"<code>connect_to_database(database=None)</code>","text":"<p>Connect to SQLite database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; conn = connect_to_database()\n&gt;&gt;&gt; type(conn)\n&lt;class 'sqlite3.Connection'&gt;\n&gt;&gt;&gt; _ = conn.cursor().execute(\"create table test(name text)\")\n&gt;&gt;&gt; conn.cursor().execute(\"select * from test\").fetchall()\n[]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>str | None</code> <p>If given, path to embedded SQLite database. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Connection</code> <code>Connection</code> <p>description</p> Source code in <code>minall/utils/database.py</code> <pre><code>def connect_to_database(database: str | None = None) -&gt; Connection:\n    \"\"\"Connect to SQLite database.\n\n    Examples:\n        &gt;&gt;&gt; conn = connect_to_database()\n        &gt;&gt;&gt; type(conn)\n        &lt;class 'sqlite3.Connection'&gt;\n        &gt;&gt;&gt; _ = conn.cursor().execute(\"create table test(name text)\")\n        &gt;&gt;&gt; conn.cursor().execute(\"select * from test\").fetchall()\n        []\n\n    Args:\n        database (str | None, optional): If given, path to embedded SQLite database. Defaults to None.\n\n    Returns:\n        Connection: _description_\n    \"\"\"\n\n    if database:\n        [p.mkdir(exist_ok=True) for p in Path(database).parents]\n        connection = sqlite3.connect(database)\n    else:\n        connection = sqlite3.connect(\":memory:\")\n    return connection\n</code></pre>"},{"location":"reference/utils/#minall.utils.parse_config","title":"<code>minall.utils.parse_config</code>","text":"<p>Data class to store and manage minet client credentials.</p> <p>The class <code>APIKeys</code> contains the following methods and properties:</p> <ul> <li><code>__init__(config)</code> - Parses the minet client configuration details.</li> <li><code>env_string()</code> - Formats the minet client credentials as an environment variable string.</li> <li><code>load_config_file(config_file)</code> - Parse client configuration details from JSON or YAML file.</li> </ul>"},{"location":"reference/utils/#minall.utils.parse_config.APIKeys","title":"<code>APIKeys</code>  <code>dataclass</code>","text":"<p>Data class to store and manage minet client credentials.</p> <p>Attributes:</p> Name Type Description <code>buzzsumo_token</code> <code>Optional[str]</code> <p>Buzzsumo API token. Optional.</p> <code>crowdtangle_token</code> <code>Optional[str]</code> <p>CrowdTangle API token. Optional.</p> <code>crowdtangle_rate_limit</code> <code>Optional[str]</code> <p>CrowdTangle API rate limit, cast as a string. Optional.</p> <code>youtube_key</code> <code>Optional[List[str]]) </code> <p>List of YouTube API keys. Optional.</p> Source code in <code>minall/utils/parse_config.py</code> <pre><code>@dataclass\nclass APIKeys:\n    \"\"\"Data class to store and manage minet client credentials.\n\n    Attributes:\n        buzzsumo_token (Optional[str]): Buzzsumo API token. Optional.\n        crowdtangle_token (Optional[str]):  CrowdTangle API token. Optional.\n        crowdtangle_rate_limit (Optional[str]): CrowdTangle API rate limit, cast as a string. Optional.\n        youtube_key (Optional[List[str]]) : List of YouTube API keys. Optional.\n    \"\"\"\n\n    buzzsumo_token: Optional[str]\n    crowdtangle_token: Optional[str]\n    crowdtangle_rate_limit: Optional[str]\n    youtube_key: Optional[List[str]]\n\n    def __init__(self, config: str | dict | None = None):\n        \"\"\"Parse and save minet API client configuration details.\n\n        Examples:\n            &gt;&gt;&gt; keys = APIKeys(config={\"youtube\": {\"key\": \"key1,key2\"}})\n            &gt;&gt;&gt; keys\n            APIKeys(buzzsumo_token=None, crowdtangle_token=None, crowdtangle_rate_limit=None, youtube_key=[\"key1\", \"key2\"])\n            &gt;&gt;&gt; keys.youtube_key\n            [\"key1, \"key2]\n\n        Args:\n            config (str | dict | None, optional): If string, string is treated like file path to JSON or YAML file that contains details; if dict, details are directly parsed; if None, details are searched from environment variables. Defaults to None.\n        \"\"\"\n        if config:\n            if isinstance(config, str):\n                parsed_config = self.load_config_file(config)\n            else:\n                parsed_config = config\n            self.buzzsumo_token = parsed_config[\"buzzsumo\"][\"token\"]\n            self.crowdtangle_token = parsed_config[\"crowdtangle\"][\"token\"]\n            self.crowdtangle_rate_limit = parsed_config[\"crowdtangle\"][\"rate_limit\"]\n            yt_keys = parsed_config[\"youtube\"][\"key\"]\n            if isinstance(yt_keys, list):\n                self.youtube_key = yt_keys\n            else:\n                self.youtube_key = parsed_config[\"youtube\"][\"key\"].split(\",\")\n        else:\n            self.buzzsumo_token = os.environ.get(\"BUZZSUMO_TOKEN\")\n            self.crowdtangle_token = os.environ.get(\"CROWDTANGLE_TOKEN\")\n            self.crowdtangle_rate_limit = os.environ.get(\"CROWDTANGLE_RATE_LIMIT\")\n            youtube_key = os.environ.get(\"YOUTUBE_KEY\")\n            if youtube_key:\n                self.youtube_key = youtube_key.split(\",\")\n            else:\n                self.youtube_key = []\n\n    @property\n    def env_string(self) -&gt; str:\n        r\"\"\"Formatted string for setting environment variables.\n\n        Examples:\n            &gt;&gt;&gt; keys = APIKeys(config={'buzzsumo': {'token': 'bz_token'}, 'crowdtangle': {'token': 'ct_token', 'rate_limit': 10}, 'youtube': {'key': 'key1,key2'}})\n            &gt;&gt;&gt; keys.env_string\n            \"BUZZSUMO_TOKEN=bz_token\\nCROWDTANGLE_TOKEN=ct_token\\nCROWDTANGLE_RATE_LIMIT=10\\nYOUTUBE_KEY=['key1', 'key2']\\n\"\n\n        Returns:\n            str: String declaring environment variables.\n        \"\"\"\n\n        return \"BUZZSUMO_TOKEN={bz}\\nCROWDTANGLE_TOKEN={ct}\\nCROWDTANGLE_RATE_LIMIT={crl}\\nYOUTUBE_KEY={yt}\\n\".format(\n            bz=self.buzzsumo_token,\n            ct=self.crowdtangle_token,\n            crl=self.crowdtangle_rate_limit,\n            yt=self.youtube_key,\n        )\n\n    def load_config_file(self, config_file: str) -&gt; dict:\n        \"\"\"Parse dictionary from JSON or YAML configuration file.\n\n        Args:\n            config_file (str): Path to JSON or YAML file.\n\n        Raises:\n            OSError: Error raised if given file path does not have the extension \".json\", \".yml\", or \".yaml\".\n\n        Returns:\n            dict: Parsed dictionary from JSON or YAML configuration file.\n        \"\"\"\n\n        with open(config_file) as f:\n            extension = Path(config_file).suffix\n            if extension == \".json\":\n                return json.load(f)\n            elif extension == \".yml\" or extension == \".yaml\":\n                return yaml.safe_load(f)\n            else:\n                raise OSError\n</code></pre>"},{"location":"reference/utils/#minall.utils.parse_config.APIKeys.env_string","title":"<code>env_string: str</code>  <code>property</code>","text":"<p>Formatted string for setting environment variables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; keys = APIKeys(config={'buzzsumo': {'token': 'bz_token'}, 'crowdtangle': {'token': 'ct_token', 'rate_limit': 10}, 'youtube': {'key': 'key1,key2'}})\n&gt;&gt;&gt; keys.env_string\n\"BUZZSUMO_TOKEN=bz_token\\nCROWDTANGLE_TOKEN=ct_token\\nCROWDTANGLE_RATE_LIMIT=10\\nYOUTUBE_KEY=['key1', 'key2']\\n\"\n</code></pre> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String declaring environment variables.</p>"},{"location":"reference/utils/#minall.utils.parse_config.APIKeys.__init__","title":"<code>__init__(config=None)</code>","text":"<p>Parse and save minet API client configuration details.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; keys = APIKeys(config={\"youtube\": {\"key\": \"key1,key2\"}})\n&gt;&gt;&gt; keys\nAPIKeys(buzzsumo_token=None, crowdtangle_token=None, crowdtangle_rate_limit=None, youtube_key=[\"key1\", \"key2\"])\n&gt;&gt;&gt; keys.youtube_key\n[\"key1, \"key2]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str | dict | None</code> <p>If string, string is treated like file path to JSON or YAML file that contains details; if dict, details are directly parsed; if None, details are searched from environment variables. Defaults to None.</p> <code>None</code> Source code in <code>minall/utils/parse_config.py</code> <pre><code>def __init__(self, config: str | dict | None = None):\n    \"\"\"Parse and save minet API client configuration details.\n\n    Examples:\n        &gt;&gt;&gt; keys = APIKeys(config={\"youtube\": {\"key\": \"key1,key2\"}})\n        &gt;&gt;&gt; keys\n        APIKeys(buzzsumo_token=None, crowdtangle_token=None, crowdtangle_rate_limit=None, youtube_key=[\"key1\", \"key2\"])\n        &gt;&gt;&gt; keys.youtube_key\n        [\"key1, \"key2]\n\n    Args:\n        config (str | dict | None, optional): If string, string is treated like file path to JSON or YAML file that contains details; if dict, details are directly parsed; if None, details are searched from environment variables. Defaults to None.\n    \"\"\"\n    if config:\n        if isinstance(config, str):\n            parsed_config = self.load_config_file(config)\n        else:\n            parsed_config = config\n        self.buzzsumo_token = parsed_config[\"buzzsumo\"][\"token\"]\n        self.crowdtangle_token = parsed_config[\"crowdtangle\"][\"token\"]\n        self.crowdtangle_rate_limit = parsed_config[\"crowdtangle\"][\"rate_limit\"]\n        yt_keys = parsed_config[\"youtube\"][\"key\"]\n        if isinstance(yt_keys, list):\n            self.youtube_key = yt_keys\n        else:\n            self.youtube_key = parsed_config[\"youtube\"][\"key\"].split(\",\")\n    else:\n        self.buzzsumo_token = os.environ.get(\"BUZZSUMO_TOKEN\")\n        self.crowdtangle_token = os.environ.get(\"CROWDTANGLE_TOKEN\")\n        self.crowdtangle_rate_limit = os.environ.get(\"CROWDTANGLE_RATE_LIMIT\")\n        youtube_key = os.environ.get(\"YOUTUBE_KEY\")\n        if youtube_key:\n            self.youtube_key = youtube_key.split(\",\")\n        else:\n            self.youtube_key = []\n</code></pre>"},{"location":"reference/utils/#minall.utils.parse_config.APIKeys.load_config_file","title":"<code>load_config_file(config_file)</code>","text":"<p>Parse dictionary from JSON or YAML configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to JSON or YAML file.</p> required <p>Raises:</p> Type Description <code>OSError</code> <p>Error raised if given file path does not have the extension \".json\", \".yml\", or \".yaml\".</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Parsed dictionary from JSON or YAML configuration file.</p> Source code in <code>minall/utils/parse_config.py</code> <pre><code>def load_config_file(self, config_file: str) -&gt; dict:\n    \"\"\"Parse dictionary from JSON or YAML configuration file.\n\n    Args:\n        config_file (str): Path to JSON or YAML file.\n\n    Raises:\n        OSError: Error raised if given file path does not have the extension \".json\", \".yml\", or \".yaml\".\n\n    Returns:\n        dict: Parsed dictionary from JSON or YAML configuration file.\n    \"\"\"\n\n    with open(config_file) as f:\n        extension = Path(config_file).suffix\n        if extension == \".json\":\n            return json.load(f)\n        elif extension == \".yml\" or extension == \".yaml\":\n            return yaml.safe_load(f)\n        else:\n            raise OSError\n</code></pre>"},{"location":"reference/utils/#minall.utils.progress_bar","title":"<code>minall.utils.progress_bar</code>","text":"<p>Context for rich progress bar.</p>"},{"location":"reference/utils/#minall.utils.progress_bar.progress_bar","title":"<code>progress_bar()</code>","text":"<p>Rich progress bar with Spinner column.</p> <p>Yields:</p> Type Description <code>Progress</code> <p>Generator[Progress, None, None]: Rich progress bar context</p> Source code in <code>minall/utils/progress_bar.py</code> <pre><code>@contextmanager\ndef progress_bar() -&gt; Generator[Progress, None, None]:\n    \"\"\"Rich progress bar with Spinner column.\n\n    Yields:\n        Generator[Progress, None, None]: Rich progress bar context\n    \"\"\"\n    with Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        SpinnerColumn(),\n        MofNCompleteColumn(),\n        TimeElapsedColumn(),\n    ) as progress:\n        yield progress\n</code></pre>"},{"location":"reference/enrichment/article_text/","title":"article_text","text":""}]}