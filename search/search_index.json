{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This site contains the project documentation for the <code>minall</code> data enrichment workflow. The project's aim is to collect and update metadata about target Web Content.</p> <p><code>minall</code> relies on the Python tool and library <code>minet</code>, which this project's name references.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<p>The documentation follows the best practice for project documentation as described by Daniele Procida in the Di\u00e1taxis documentation framework and consists of four separate parts:</p> <ol> <li>Tutorials</li> <li>How-To Guides</li> <li>Reference</li> <li>Explanation</li> </ol> <p>Quickly find what you're looking for depending on your use case by looking at the different pages.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This project was developed as a response to research needs in the European project De Facto and with the help of members of the m\u00e9dialab at Sciences Po. In particular, the project depends on the excellent work of Guillaume Plique and other contributors to the m\u00e9dialab's tool <code>minet</code>.</p>"},{"location":"explanation/","title":"Explanation","text":"<p>This part of the project documentation focuses on an understanding-oriented approach. You'll get a chance to read about the background of the project, as well as reasoning about how it was implemented.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Give context and background on your library</li> <li>Explain why you created it</li> <li>Provide multiple examples and approaches of how   to work with it</li> <li>Help the reader make connections</li> <li>Avoid writing instructions or technical descriptions   here</li> </ul> <p>Example from https://realpython.com/python-project-documentation-with-mkdocs/</p>"},{"location":"how-to-guides/","title":"How-To Guides","text":"<p>This part of the project documentation focuses on a problem-oriented approach. You'll tackle common tasks that you might have, with the help of the code provided in this project.</p>"},{"location":"how-to-guides/#how-to-add-two-numbers","title":"How To Add Two Numbers?","text":"<p>You have two numbers and you need to add them together. You're in luck! The <code>calculator</code> package can help you get this done.</p> <p>Download the code from this GitHub repository and place the <code>calculator/</code> folder in the same directory as your Python script:</p> <pre><code>your_project/\n\u2502\n\u251c\u2500\u2500 calculator/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 calculations.py\n\u2502\n\u2514\u2500\u2500 your_script.py\n</code></pre> <p>Inside of <code>your_script.py</code> you can now import the <code>add()</code> function from the <code>calculator.calculations</code> module:</p> <pre><code># your_script.py\nfrom calculator.calculations import add\n</code></pre> <p>After you've imported the function, you can use it to add any two numbers that you need to add:</p> <pre><code># your_script.py\nfrom calculator.calculations import add\n\nprint(add(20, 22))  # OUTPUT: 42.0\n</code></pre> <p>You're now able to add any two numbers, and you'll always get a <code>float</code> as a result.</p> <p>Example from https://realpython.com/python-project-documentation-with-mkdocs/</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>This part of the project documentation focuses on a learning-oriented approach. You'll learn how to get started with the code in this project.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Help newcomers with getting started</li> <li>Teach readers about your library by making them   write code</li> <li>Inspire confidence through examples that work for   everyone, repeatably</li> <li>Give readers an immediate sense of achievement</li> <li>Show concrete examples, no abstractions</li> <li>Provide the minimum necessary explanation</li> <li>Avoid any distractions</li> </ul> <p>Example from https://realpython.com/python-project-documentation-with-mkdocs/</p>"},{"location":"reference/cli/","title":"CLI tools","text":""},{"location":"reference/cli/#minall.cli.run","title":"<code>minall.cli.run</code>","text":"<p>CLI action for minall workflow.</p> <p>This module contains the function <code>cli()</code>, which runs the minall workflow as a CLI tool. Using the imported helper function <code>cli_args()</code>, the function parses command-line arguments and uses the necessary parameters to create and instance of the <code>Minall</code> class. Finally, the function deploys the whole <code>Minall</code> workflow.</p>"},{"location":"reference/cli/#minall.cli.run.cli","title":"<code>cli()</code>","text":"<p>Run minall workflow from the command line.</p> Source code in <code>minall/cli/run.py</code> <pre><code>def cli():\n    \"\"\"Run minall workflow from the command line.\"\"\"\n\n    args = cli_args()\n\n    app = Minall(**args)\n\n    app.collect_and_coalesce()\n\n    app.export()\n</code></pre>"},{"location":"reference/cli/#minall.cli.parse_args","title":"<code>minall.cli.parse_args</code>","text":"<p>Helper functions for CLI action.</p> <p>This module contains the following helper functions for parsing command-line arguments:</p> <ul> <li><code>cli_args()</code> - Parse CLI arguments.</li> <li><code>dir_path(path_name)</code> - Create directory and necessary parent directories.</li> <li><code>file_path(path_name)</code> - Verify existence of given file.</li> <li><code>has_parent(path_name)</code> - Create necessary parent directories for file path.</li> </ul>"},{"location":"reference/cli/#minall.cli.parse_args.cli_args","title":"<code>cli_args()</code>","text":"<p>Function to call and parse command-line arguments.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of parsed command-line arguments.</p> Source code in <code>minall/cli/parse_args.py</code> <pre><code>def cli_args() -&gt; dict:\n    \"\"\"Function to call and parse command-line arguments.\n\n    Returns:\n        dict: Dictionary of parsed command-line arguments.\n    \"\"\"\n    parser = ArgumentParser(\n        add_help=True, prog=\"Minall\", formatter_class=RawDescriptionHelpFormatter\n    )\n    parser.add_argument(\n        \"--database\",\n        dest=\"database\",\n        required=False,\n        type=has_parent,\n        help=\"[Optional] Path to SQLite database. If not given, database written to memory.\",\n    )\n    parser.add_argument(\n        \"--config\",\n        dest=\"config\",\n        type=file_path,\n        required=False,\n        help=\"[Optional] Path to configuration file. If not given, environment variables are expected.\",\n    )\n    parser.add_argument(\n        \"--output-dir\",\n        dest=\"output_dir\",\n        type=dir_path,\n        required=True,\n        help=\"[Required] Path to directory in which a links and shared_content file will be written.\",\n    )\n    parser.add_argument(\n        \"--links\",\n        dest=\"links_file\",\n        type=file_path,\n        required=True,\n        help=\"[Required] Path to links file.\",\n    )\n    parser.add_argument(\n        \"--url-col\",\n        dest=\"url_col\",\n        type=str,\n        required=True,\n        help=\"[Required] Name of URL column in links file.\",\n    )\n    parser.add_argument(\n        \"--shared-content\",\n        dest=\"shared_content_file\",\n        type=file_path,\n        required=False,\n        help=\"[Optional] Path to shared_content file.\",\n    )\n    parser.add_argument(\n        \"--buzzsumo-only\",\n        dest=\"buzzsumo_only\",\n        default=False,\n        required=False,\n        action=\"store_true\",\n        help=\"[Optional] Flag indicating only Buzzsumo API will be called on links file.\",\n    )\n    args = parser.parse_args()\n    return args.__dict__\n</code></pre>"},{"location":"reference/cli/#minall.cli.parse_args.dir_path","title":"<code>dir_path(path_name)</code>","text":"<p>Function to convert argument to created directory.</p> <p>Parameters:</p> Name Type Description Default <code>path_name</code> <code>str</code> <p>Path to target directory.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to prepared directory.</p> Source code in <code>minall/cli/parse_args.py</code> <pre><code>def dir_path(path_name: str) -&gt; str:\n    \"\"\"Function to convert argument to created directory.\n\n    Args:\n        path_name (str): Path to target directory.\n\n    Returns:\n        str: Path to prepared directory.\n    \"\"\"\n    if Path(path_name).is_dir():\n        return path_name\n    else:\n        Path(path_name).mkdir(exist_ok=True)\n        [p.mkdir(exist_ok=True) for p in Path(path_name).parents]\n        return path_name\n</code></pre>"},{"location":"reference/cli/#minall.cli.parse_args.file_path","title":"<code>file_path(path_name)</code>","text":"<p>Function to convert argument to verified, found file path.</p> <p>Parameters:</p> Name Type Description Default <code>path_name</code> <code>str</code> <p>Path to data file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Data file not found at given path.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Verified path to data file.</p> Source code in <code>minall/cli/parse_args.py</code> <pre><code>def file_path(path_name: str) -&gt; str:\n    \"\"\"Function to convert argument to verified, found file path.\n\n    Args:\n        path_name (str): Path to data file.\n\n    Raises:\n        FileNotFoundError: Data file not found at given path.\n\n    Returns:\n        str: Verified path to data file.\n    \"\"\"\n    if Path(path_name).is_file():\n        return path_name\n    else:\n        raise FileNotFoundError(path_name)\n</code></pre>"},{"location":"reference/cli/#minall.cli.parse_args.has_parent","title":"<code>has_parent(path_name)</code>","text":"<p>Function to convert argument to file path with created parent directories.</p> <p>Parameters:</p> Name Type Description Default <code>path_name</code> <code>str</code> <p>Path to out-file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to out-file with created parent directories.</p> Source code in <code>minall/cli/parse_args.py</code> <pre><code>def has_parent(path_name: str) -&gt; str:\n    \"\"\"Function to convert argument to file path with created parent directories.\n\n    Args:\n        path_name (str): Path to out-file.\n\n    Returns:\n        str: Path to out-file with created parent directories.\n    \"\"\"\n    [p.mkdir(exist_ok=True) for p in Path(path_name).parents]\n    return path_name\n</code></pre>"},{"location":"reference/enrichment/","title":"Enrichment tools","text":"<p>Little blurb</p>"},{"location":"reference/enrichment/#minall.enrichment.enrichment","title":"<code>minall.enrichment.enrichment</code>","text":"<p>Class for data collection and coalescing.</p> <p>With the class <code>Enrichment</code>, this module manages the data collection process.</p> <p>The class contains the following methods:</p> <ul> <li><code>__init__(links_table, shared_content_table, keys)</code> -</li> </ul>"},{"location":"reference/enrichment/#minall.enrichment.enrichment.Enrichment","title":"<code>Enrichment</code>","text":"Source code in <code>minall/enrichment/enrichment.py</code> <pre><code>class Enrichment:\n    def __init__(\n        self,\n        links_table: BaseTable,\n        shared_content_table: BaseTable,\n        keys: APIKeys,\n    ) -&gt; None:\n        \"\"\"From given API keys and URL data set, filter URLs by domain and initialize data enrichment class.\n\n        Args:\n            links_table (BaseTable): BaseTable class instance of SQL table for URL dataset.\n            shared_content_table (BaseTable): BaseTable class instance of SQL table for shared content related to URLs in dataset.\n            keys (APIKeys): APIKeys class instance of minet API client configurations.\n        \"\"\"\n\n        self.links_table = links_table\n        self.shared_content_table = shared_content_table\n        self.keys = keys\n        self.filtered_links = FilteredLinks(self.links_table)\n\n    def buzzsumo(self):\n        \"\"\"For all URLs, collect data from Buzzsumo and coalesce in the database's 'links' table.\"\"\"\n\n        if self.keys.buzzsumo_token:\n            get_buzzsumo_data(\n                data=self.filtered_links.all_links,\n                token=self.keys.buzzsumo_token,\n                outfile=self.links_table.outfile,\n            )\n            self.links_table.coalesce(infile=self.links_table.outfile)\n\n    def scraper(self):\n        \"\"\"For select URLs, collect data via scraping and coalesce in the database's 'links' table.\"\"\"\n\n        # In multiple threads, scrape HTML data and write to a CSV file\n        get_article_text(\n            data=self.filtered_links.to_scrape, outfile=self.links_table.outfile\n        )\n        # Coalesce the results in the CSV File to the links table\n        self.links_table.coalesce(infile=self.links_table.outfile)\n\n    def other_social_media(self):\n        \"\"\"For select URLs, update the 'work_type' column in the database's 'links' table with the value 'SocialMediaPosting'.\"\"\"\n        # Assign default type to social media post\n        add_type_data(\n            data=self.filtered_links.other_social, outfile=self.links_table.outfile\n        )\n        # Coalesce the results in the CSV File to the links table\n        self.links_table.coalesce(infile=self.links_table.outfile)\n\n    def facebook(self):\n        \"\"\"For Facebook URLs, collect data from CrowdTangle and coalesce in the database's 'links' and 'shared_content' tables.\"\"\"\n        if self.keys.crowdtangle_token:\n            get_facebook_post_data(\n                data=self.filtered_links.facebook,\n                token=self.keys.crowdtangle_token,\n                rate_limit=self.keys.crowdtangle_rate_limit,\n                links_outfile=self.links_table.outfile,\n                shared_content_outfile=self.shared_content_table.outfile,\n            )\n            # Coalesce the results in the CSV File to the links table\n            self.links_table.coalesce(infile=self.links_table.outfile)\n            self.shared_content_table.coalesce(infile=self.shared_content_table.outfile)\n\n    def youtube(self):\n        \"\"\"For YouTube URLs, collect data from YouTube API and coalesce in the database's 'links' table.\"\"\"\n        if self.keys.youtube_key:\n            # In single thread, collect YouTube API data and write to a CSV file\n            get_youtube_data(\n                data=self.filtered_links.youtube,\n                keys=self.keys.youtube_key,\n                outfile=self.links_table.outfile,\n            )\n            # Coalesce the results in the CSV File to the links table\n            self.links_table.coalesce(infile=self.links_table.outfile)\n\n    def __call__(self, buzzsumo_only: bool):\n        executor = SQLiteWrapper(connection=self.links_table.connection)\n        # apply domain to all urls\n        for link in self.filtered_links.all_links:\n            query, domain = apply_domain(link)\n            if query and domain:\n                self.links_table.connection\n                executor(query=query)\n\n        if not buzzsumo_only:\n            if len(self.filtered_links.youtube) &gt; 0:\n                self.youtube()\n            if len(self.filtered_links.facebook) &gt; 0:\n                self.facebook()\n            if len(self.filtered_links.other_social) &gt; 0:\n                self.other_social_media()\n            if len(self.filtered_links.to_scrape) &gt; 0:\n                self.scraper()\n        self.buzzsumo()\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.enrichment.Enrichment.__init__","title":"<code>__init__(links_table, shared_content_table, keys)</code>","text":"<p>From given API keys and URL data set, filter URLs by domain and initialize data enrichment class.</p> <p>Parameters:</p> Name Type Description Default <code>links_table</code> <code>BaseTable</code> <p>BaseTable class instance of SQL table for URL dataset.</p> required <code>shared_content_table</code> <code>BaseTable</code> <p>BaseTable class instance of SQL table for shared content related to URLs in dataset.</p> required <code>keys</code> <code>APIKeys</code> <p>APIKeys class instance of minet API client configurations.</p> required Source code in <code>minall/enrichment/enrichment.py</code> <pre><code>def __init__(\n    self,\n    links_table: BaseTable,\n    shared_content_table: BaseTable,\n    keys: APIKeys,\n) -&gt; None:\n    \"\"\"From given API keys and URL data set, filter URLs by domain and initialize data enrichment class.\n\n    Args:\n        links_table (BaseTable): BaseTable class instance of SQL table for URL dataset.\n        shared_content_table (BaseTable): BaseTable class instance of SQL table for shared content related to URLs in dataset.\n        keys (APIKeys): APIKeys class instance of minet API client configurations.\n    \"\"\"\n\n    self.links_table = links_table\n    self.shared_content_table = shared_content_table\n    self.keys = keys\n    self.filtered_links = FilteredLinks(self.links_table)\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.enrichment.Enrichment.buzzsumo","title":"<code>buzzsumo()</code>","text":"<p>For all URLs, collect data from Buzzsumo and coalesce in the database's 'links' table.</p> Source code in <code>minall/enrichment/enrichment.py</code> <pre><code>def buzzsumo(self):\n    \"\"\"For all URLs, collect data from Buzzsumo and coalesce in the database's 'links' table.\"\"\"\n\n    if self.keys.buzzsumo_token:\n        get_buzzsumo_data(\n            data=self.filtered_links.all_links,\n            token=self.keys.buzzsumo_token,\n            outfile=self.links_table.outfile,\n        )\n        self.links_table.coalesce(infile=self.links_table.outfile)\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.enrichment.Enrichment.facebook","title":"<code>facebook()</code>","text":"<p>For Facebook URLs, collect data from CrowdTangle and coalesce in the database's 'links' and 'shared_content' tables.</p> Source code in <code>minall/enrichment/enrichment.py</code> <pre><code>def facebook(self):\n    \"\"\"For Facebook URLs, collect data from CrowdTangle and coalesce in the database's 'links' and 'shared_content' tables.\"\"\"\n    if self.keys.crowdtangle_token:\n        get_facebook_post_data(\n            data=self.filtered_links.facebook,\n            token=self.keys.crowdtangle_token,\n            rate_limit=self.keys.crowdtangle_rate_limit,\n            links_outfile=self.links_table.outfile,\n            shared_content_outfile=self.shared_content_table.outfile,\n        )\n        # Coalesce the results in the CSV File to the links table\n        self.links_table.coalesce(infile=self.links_table.outfile)\n        self.shared_content_table.coalesce(infile=self.shared_content_table.outfile)\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.enrichment.Enrichment.other_social_media","title":"<code>other_social_media()</code>","text":"<p>For select URLs, update the 'work_type' column in the database's 'links' table with the value 'SocialMediaPosting'.</p> Source code in <code>minall/enrichment/enrichment.py</code> <pre><code>def other_social_media(self):\n    \"\"\"For select URLs, update the 'work_type' column in the database's 'links' table with the value 'SocialMediaPosting'.\"\"\"\n    # Assign default type to social media post\n    add_type_data(\n        data=self.filtered_links.other_social, outfile=self.links_table.outfile\n    )\n    # Coalesce the results in the CSV File to the links table\n    self.links_table.coalesce(infile=self.links_table.outfile)\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.enrichment.Enrichment.scraper","title":"<code>scraper()</code>","text":"<p>For select URLs, collect data via scraping and coalesce in the database's 'links' table.</p> Source code in <code>minall/enrichment/enrichment.py</code> <pre><code>def scraper(self):\n    \"\"\"For select URLs, collect data via scraping and coalesce in the database's 'links' table.\"\"\"\n\n    # In multiple threads, scrape HTML data and write to a CSV file\n    get_article_text(\n        data=self.filtered_links.to_scrape, outfile=self.links_table.outfile\n    )\n    # Coalesce the results in the CSV File to the links table\n    self.links_table.coalesce(infile=self.links_table.outfile)\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.enrichment.Enrichment.youtube","title":"<code>youtube()</code>","text":"<p>For YouTube URLs, collect data from YouTube API and coalesce in the database's 'links' table.</p> Source code in <code>minall/enrichment/enrichment.py</code> <pre><code>def youtube(self):\n    \"\"\"For YouTube URLs, collect data from YouTube API and coalesce in the database's 'links' table.\"\"\"\n    if self.keys.youtube_key:\n        # In single thread, collect YouTube API data and write to a CSV file\n        get_youtube_data(\n            data=self.filtered_links.youtube,\n            keys=self.keys.youtube_key,\n            outfile=self.links_table.outfile,\n        )\n        # Coalesce the results in the CSV File to the links table\n        self.links_table.coalesce(infile=self.links_table.outfile)\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.utils","title":"<code>minall.enrichment.utils</code>","text":"<p>Functions for data collection.</p> <p>This module provides the following class and functions:</p> <ul> <li><code>get_domain(url)</code> - Parse domain from URL string.</li> <li><code>apply_domain(url)</code> - Generate SQL query to insert domain into table.</li> <li><code>FilteredLinks(table)</code> - From SQL table, select subsets of URLs based on domain name.</li> </ul>"},{"location":"reference/enrichment/#minall.enrichment.utils.FilteredLinks","title":"<code>FilteredLinks</code>","text":"<p>Selects all URLs from SQL table and returns subsets.</p> Source code in <code>minall/enrichment/utils.py</code> <pre><code>class FilteredLinks:\n    \"\"\"Selects all URLs from SQL table and returns subsets.\"\"\"\n\n    def __init__(self, table: BaseTable) -&gt; None:\n        \"\"\"Select and store all URLs from a target SQL table.\n\n        Args:\n            table (BaseTable): Target SQL table.\n        \"\"\"\n        cursor = table.connection.cursor()\n        self.all_links = [\n            row[0]\n            for row in cursor.execute(\n                f\"SELECT url FROM {table.table.table_name}\"\n            ).fetchall()\n        ]\n\n    @property\n    def youtube(self) -&gt; List[str]:\n        \"\"\"List of URLs from YouTube.\n\n        Returns:\n            List[str]: List of URL strings.\n        \"\"\"\n        return [url for url in self.all_links if is_youtube_url(url=url)]\n\n    @property\n    def facebook(self) -&gt; List[str]:\n        \"\"\"List of URLs from Facebook.\n\n        Returns:\n            List[str]: List of URL strings.\n        \"\"\"\n        return [url for url in self.all_links if is_facebook_url(url=url)]\n\n    @property\n    def other_social(self) -&gt; List[str]:\n        \"\"\"List of URLs from social media platforms.\n\n        Returns:\n            List[str]: List of URL strings.\n        \"\"\"\n        return [\n            url\n            for url in self.all_links\n            if get_domain(url=url)\n            in [\n                \"facebook.com\",\n                \"youtube.com\",\n                \"tiktok.com\",\n                \"instagram.com\",\n                \"twitter.com\",\n                \"snapchat.com\",\n            ]\n        ]\n\n    @property\n    def to_scrape(self) -&gt; List[str]:\n        \"\"\"List of URLs not from social media platforms.\n\n        Returns:\n            List[str]: List of URL strings.\n        \"\"\"\n        return [\n            url\n            for url in self.all_links\n            if get_domain(url=url)\n            not in [\n                \"facebook.com\",\n                \"youtube.com\",\n                \"tiktok.com\",\n                \"instagram.com\",\n                \"twitter.com\",\n                \"snapchat.com\",\n            ]\n        ]\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.utils.FilteredLinks.facebook","title":"<code>facebook: List[str]</code>  <code>property</code>","text":"<p>List of URLs from Facebook.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of URL strings.</p>"},{"location":"reference/enrichment/#minall.enrichment.utils.FilteredLinks.other_social","title":"<code>other_social: List[str]</code>  <code>property</code>","text":"<p>List of URLs from social media platforms.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of URL strings.</p>"},{"location":"reference/enrichment/#minall.enrichment.utils.FilteredLinks.to_scrape","title":"<code>to_scrape: List[str]</code>  <code>property</code>","text":"<p>List of URLs not from social media platforms.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of URL strings.</p>"},{"location":"reference/enrichment/#minall.enrichment.utils.FilteredLinks.youtube","title":"<code>youtube: List[str]</code>  <code>property</code>","text":"<p>List of URLs from YouTube.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of URL strings.</p>"},{"location":"reference/enrichment/#minall.enrichment.utils.FilteredLinks.__init__","title":"<code>__init__(table)</code>","text":"<p>Select and store all URLs from a target SQL table.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>BaseTable</code> <p>Target SQL table.</p> required Source code in <code>minall/enrichment/utils.py</code> <pre><code>def __init__(self, table: BaseTable) -&gt; None:\n    \"\"\"Select and store all URLs from a target SQL table.\n\n    Args:\n        table (BaseTable): Target SQL table.\n    \"\"\"\n    cursor = table.connection.cursor()\n    self.all_links = [\n        row[0]\n        for row in cursor.execute(\n            f\"SELECT url FROM {table.table.table_name}\"\n        ).fetchall()\n    ]\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.utils.apply_domain","title":"<code>apply_domain(url)</code>","text":"<p>Compose SQL query to update the domain column of a URL's row in the 'links' SQLite table.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; apply_domain(url=\"https://www.youtube.com/channel/MkDocs\")\n(\"UPDATE links SET domain = 'youtube.com' WHERE url = 'https://www.youtube.com/channel/MkDocs'\", 'youtube.com')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL string.</p> required <p>Returns:</p> Type Description <code>Tuple[str | None, str | None]</code> <p>Tuple[str | None, str | None]: If domain was parsed, a tuple containing the SQL query and domain name.</p> Source code in <code>minall/enrichment/utils.py</code> <pre><code>def apply_domain(url: str) -&gt; Tuple[str | None, str | None]:\n    \"\"\"Compose SQL query to update the domain column of a URL's row in the 'links' SQLite table.\n\n    Examples:\n        &gt;&gt;&gt; apply_domain(url=\"https://www.youtube.com/channel/MkDocs\")\n        (\"UPDATE links SET domain = 'youtube.com' WHERE url = 'https://www.youtube.com/channel/MkDocs'\", 'youtube.com')\n\n    Args:\n        url (str): URL string.\n\n    Returns:\n        Tuple[str | None, str | None]: If domain was parsed, a tuple containing the SQL query and domain name.\n    \"\"\"\n\n    query = None\n    domain = get_domain(url)\n    if domain:\n        query = f\"UPDATE {LinksConstants.table_name} SET domain = '{domain}' WHERE {LinksConstants.primary_key} = '{url}'\"\n    return query, domain\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.utils.get_domain","title":"<code>get_domain(url)</code>","text":"<p>Parse the domain name of a given URL string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_domain(url=\"https://www.youtube.com/channel/MkDocs\")\n'youtube.com'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL string.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: If successfully parsed, domain name.</p> Source code in <code>minall/enrichment/utils.py</code> <pre><code>def get_domain(url: str) -&gt; str | None:\n    \"\"\"Parse the domain name of a given URL string.\n\n    Examples:\n        &gt;&gt;&gt; get_domain(url=\"https://www.youtube.com/channel/MkDocs\")\n        'youtube.com'\n\n    Args:\n        url (str): URL string.\n\n    Returns:\n        str | None: If successfully parsed, domain name.\n    \"\"\"\n\n    domain_name = ural.get_domain_name(url)\n    if domain_name in YOUTUBE_DOMAINS:\n        domain_name = \"youtube.com\"\n    return domain_name\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.article_text","title":"<code>minall.enrichment.article_text</code>","text":"<p>Something.</p>"},{"location":"reference/enrichment/#minall.enrichment.article_text.get_data","title":"<code>minall.enrichment.article_text.get_data</code>","text":"<p>Something.</p>"},{"location":"reference/enrichment/#minall.enrichment.article_text.scraper","title":"<code>minall.enrichment.article_text.scraper</code>","text":"<p>Something.</p>"},{"location":"reference/enrichment/#minall.enrichment.article_text.constants","title":"<code>minall.enrichment.article_text.constants</code>","text":"<p>Something.</p>"},{"location":"reference/enrichment/#minall.enrichment.article_text.constants.NormalizedScrapedWebPage","title":"<code>NormalizedScrapedWebPage</code>  <code>dataclass</code>","text":"<p>             Bases: <code>TabularRecord</code></p> <p>summary</p> <p>Attributes:</p> Name Type Description <code>url</code> <code>str</code> <p>description</p> <code>title</code> <code>str | None</code> <p>description</p> <code>text</code> <code>str | None</code> <p>description</p> <code>date_published</code> <code>str | None</code> <p>description</p> <code>work_type</code> <code>str</code> <p>description. Default = \"WebPage\".</p> Source code in <code>minall/enrichment/article_text/constants.py</code> <pre><code>@dataclass\nclass NormalizedScrapedWebPage(TabularRecord):\n    \"\"\"_summary_\n\n    Attributes:\n        url (str): __description__\n        title (str | None): __description__\n        text (str | None): __description__\n        date_published (str | None): __description__\n        work_type (str): __description__. Default = \"WebPage\".\n    \"\"\"\n\n    url: str\n    title: str | None\n    text: str | None\n    date_published: str | None\n    work_type: str = \"WebPage\"\n\n    @classmethod\n    def from_payload(\n        cls,\n        url: str,\n        result: TrafilaturaResult,\n    ) -&gt; \"NormalizedScrapedWebPage\":\n        return NormalizedScrapedWebPage(\n            url=url, title=result.title, text=result.content, date_published=result.date\n        )\n</code></pre>"},{"location":"reference/enrichment/#minall.enrichment.article_text.contexts","title":"<code>minall.enrichment.article_text.contexts</code>","text":"<p>Something.</p>"},{"location":"reference/main/","title":"Minall","text":"<p>To facilitate the project's use as a Python library and as a CLI tool, <code>minall</code>'s workflow is managed via an exportable class, <code>Minall</code>.</p> <p>By creating a class instance of <code>Minall</code>, the following preliminary steps are taken:</p> <ul> <li>API credentials for the <code>minet</code> clients are parsed. (param: <code>config</code>)</li> <li>File paths to the workflow's eventual output, CSV files for the target URLs (<code>links.csv</code>) and their shared content (<code>shared_content.csv</code>), are prepared. This includes the creation of any necessary parent directories. (param: <code>out_dir</code>)</li> <li>The SQLite database connection is created. The connection can either be in-memory or, if a file path is provided, to an embedded SQLite database. If the user wants <code>Minall</code> to create and store the workflow's results in an SQLite database file, simply providing a file path will also create the file. (param: <code>database</code>)</li> <li>Through the SQLite connection, SQL tables are created for the user-provided data files. A file of target URLs is necessary, whose data will be parsed and inserted into the 'links' SQL table. (param: <code>links_file</code>, <code>url_col</code>, <code>shared_content_file</code>)</li> <li>The class instance remembers whether to (a) deploy all of the <code>minall</code> enrichment workflow or (b) only collect the generalized Buzzsumo metadata. (param: <code>buzzsumo_only</code>)</li> </ul>"},{"location":"reference/main/#minall.main","title":"<code>minall.main</code>","text":"<p>Minall enrichment workflow.</p> <p>With the class <code>Minall</code>, this module manages the entire workflow.</p> <p>The class contains the following methods:</p> <ul> <li><code>__init__(database, config, output_dir, links_file, url_col, shared_content_file, buzzsumo_only)</code> - Intialize SQLite database and out-file paths.</li> <li><code>collect_and_coalesce()</code> - Collect new data and coalesce with existing data in relevant SQL tables.</li> <li><code>export()</code> - Write enriched SQL tables to CSV out-files.</li> </ul>"},{"location":"reference/main/#minall.main.Minall","title":"<code>Minall</code>","text":"<p>Class to store variables and execute steps of enrichment.</p> Source code in <code>minall/main.py</code> <pre><code>class Minall:\n    \"\"\"Class to store variables and execute steps of enrichment.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None,\n        config: str | dict | None,\n        output_dir: str,\n        links_file: str,\n        url_col: str,\n        shared_content_file: str | None = None,\n        buzzsumo_only: bool = False,\n    ) -&gt; None:\n        \"\"\"Intialize SQLite database and out-file paths.\n\n        Examples:\n            &gt;&gt;&gt; # Set file path variables.\n            &gt;&gt;&gt; OUT_DIR = Path(__file__).parent.parent.joinpath(\"docs\").joinpath(\"doctest\")\n            &gt;&gt;&gt; LINKS_FILE = OUT_DIR.joinpath('minall_init_example.csv')\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Create Minall instance.\n            &gt;&gt;&gt; minall = Minall(database=None, config={}, output_dir=str(OUT_DIR), links_file=str(LINKS_FILE), url_col='url')\n            &gt;&gt;&gt; minall.links_table.table\n            LinksConstants(table_name='links', primary_key='url')\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Check that Minall's SQLite database connection has committed 1 change (creating the 'links' table).\n            &gt;&gt;&gt; minall.connection.total_changes\n            1\n\n        Args:\n            database (str | None): Path name to SQLite database. If None, creates database in memory.\n            config (str | dict | None): Credentials for API keys.\n            output_dir (str): Path name to directory for enriched CSV files.\n            links_file (str): Path name to in-file for URLs.\n            url_col (str): Name of URL column in URLs file.\n            shared_content_file (str | None): Path name to CSV file of shared content related to URLs.\n            buzzsumo_only (bool, optional): Whether to only run Buzzsumo enrichment. Defaults to False.\n        \"\"\"\n\n        # Connect to the SQLite database\n        self.connection = connect_to_database(database=database)\n\n        # Parse API keys from config file / dict\n        self.keys = APIKeys(config=config)\n\n        # Store Buzzsumo-only flag\n        self.buzzsumo_only = buzzsumo_only\n\n        # Set paths to output directory and out-files\n        [p.mkdir(exist_ok=True) for p in Path(output_dir).parents]\n        self.output_dir = Path(output_dir)\n        self.links_file = self.output_dir.joinpath(\"links.csv\")\n        self.shared_contents_file = self.output_dir.joinpath(\"shared_content.csv\")\n\n        # Input original data into the database\n        self.links_table = BaseTable(\n            sqlite_connection=self.connection,\n            infile=links_file,\n            outfile=self.links_file,\n            table=LinksConstants(),\n            url_col=url_col,\n        )\n\n        self.shared_content_table = BaseTable(\n            sqlite_connection=self.connection,\n            infile=shared_content_file,\n            outfile=self.shared_contents_file,\n            table=ShareContentConstants(),\n        )\n\n    def collect_and_coalesce(self):\n        \"\"\"Collect new data and coalesce with existing data in relevant SQL tables.\n\n        This method creates an instance of the class `Enrichment` (from `minall.enrichment.enrichment`), providing the target URL table ('links' table, `self.links_table`), the minet API credentials (`self.keys`), and the related shared content table (`self.shared_content_table`) which may go unused depending on parameters used when `Enrichment` is called.\n\n        Having prepared the `Enrichment` instance, the method then calls the class, providing its `self.buzzsumo_only` instance attribute as the argument for `Enrichment`'s `buzzsumo_only` parameter. The latter boolean parameter determines whether all of the `Enrichment` class's methods will be deployed or only its Buzzsumo method.\n        \"\"\"\n        enricher = Enrichment(\n            links_table=self.links_table,\n            shared_content_table=self.shared_content_table,\n            keys=self.keys,\n        )\n        enricher(buzzsumo_only=self.buzzsumo_only)\n\n    def export(self) -&gt; Tuple[Path, Path]:\n        \"\"\"Write enriched SQL tables to CSV out-files.\n\n        This method simply exports to CSV files both of the `Minall` class instance's SQL tables, `self.links_table` and `self.shared_content_table`. The class that manages the SQL tables (`minall.tables.base.BaseTable`), stores each table's out-file path as an instance variable. The parent directory for both out-files was declared during `Minall`'s `__init__()` method via the parameter `output_dir`, from which the out-file paths were subsequently derived.\n\n        Returns:\n            Tuple[Path, Path]: Paths to links and shared content CSV files.\n        \"\"\"\n        self.links_table.export()\n        self.shared_content_table.export()\n        return self.links_file, self.shared_contents_file\n</code></pre>"},{"location":"reference/main/#minall.main.Minall.__init__","title":"<code>__init__(database, config, output_dir, links_file, url_col, shared_content_file=None, buzzsumo_only=False)</code>","text":"<p>Intialize SQLite database and out-file paths.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Set file path variables.\n&gt;&gt;&gt; OUT_DIR = Path(__file__).parent.parent.joinpath(\"docs\").joinpath(\"doctest\")\n&gt;&gt;&gt; LINKS_FILE = OUT_DIR.joinpath('minall_init_example.csv')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create Minall instance.\n&gt;&gt;&gt; minall = Minall(database=None, config={}, output_dir=str(OUT_DIR), links_file=str(LINKS_FILE), url_col='url')\n&gt;&gt;&gt; minall.links_table.table\nLinksConstants(table_name='links', primary_key='url')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check that Minall's SQLite database connection has committed 1 change (creating the 'links' table).\n&gt;&gt;&gt; minall.connection.total_changes\n1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>str | None</code> <p>Path name to SQLite database. If None, creates database in memory.</p> required <code>config</code> <code>str | dict | None</code> <p>Credentials for API keys.</p> required <code>output_dir</code> <code>str</code> <p>Path name to directory for enriched CSV files.</p> required <code>links_file</code> <code>str</code> <p>Path name to in-file for URLs.</p> required <code>url_col</code> <code>str</code> <p>Name of URL column in URLs file.</p> required <code>shared_content_file</code> <code>str | None</code> <p>Path name to CSV file of shared content related to URLs.</p> <code>None</code> <code>buzzsumo_only</code> <code>bool</code> <p>Whether to only run Buzzsumo enrichment. Defaults to False.</p> <code>False</code> Source code in <code>minall/main.py</code> <pre><code>def __init__(\n    self,\n    database: str | None,\n    config: str | dict | None,\n    output_dir: str,\n    links_file: str,\n    url_col: str,\n    shared_content_file: str | None = None,\n    buzzsumo_only: bool = False,\n) -&gt; None:\n    \"\"\"Intialize SQLite database and out-file paths.\n\n    Examples:\n        &gt;&gt;&gt; # Set file path variables.\n        &gt;&gt;&gt; OUT_DIR = Path(__file__).parent.parent.joinpath(\"docs\").joinpath(\"doctest\")\n        &gt;&gt;&gt; LINKS_FILE = OUT_DIR.joinpath('minall_init_example.csv')\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create Minall instance.\n        &gt;&gt;&gt; minall = Minall(database=None, config={}, output_dir=str(OUT_DIR), links_file=str(LINKS_FILE), url_col='url')\n        &gt;&gt;&gt; minall.links_table.table\n        LinksConstants(table_name='links', primary_key='url')\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Check that Minall's SQLite database connection has committed 1 change (creating the 'links' table).\n        &gt;&gt;&gt; minall.connection.total_changes\n        1\n\n    Args:\n        database (str | None): Path name to SQLite database. If None, creates database in memory.\n        config (str | dict | None): Credentials for API keys.\n        output_dir (str): Path name to directory for enriched CSV files.\n        links_file (str): Path name to in-file for URLs.\n        url_col (str): Name of URL column in URLs file.\n        shared_content_file (str | None): Path name to CSV file of shared content related to URLs.\n        buzzsumo_only (bool, optional): Whether to only run Buzzsumo enrichment. Defaults to False.\n    \"\"\"\n\n    # Connect to the SQLite database\n    self.connection = connect_to_database(database=database)\n\n    # Parse API keys from config file / dict\n    self.keys = APIKeys(config=config)\n\n    # Store Buzzsumo-only flag\n    self.buzzsumo_only = buzzsumo_only\n\n    # Set paths to output directory and out-files\n    [p.mkdir(exist_ok=True) for p in Path(output_dir).parents]\n    self.output_dir = Path(output_dir)\n    self.links_file = self.output_dir.joinpath(\"links.csv\")\n    self.shared_contents_file = self.output_dir.joinpath(\"shared_content.csv\")\n\n    # Input original data into the database\n    self.links_table = BaseTable(\n        sqlite_connection=self.connection,\n        infile=links_file,\n        outfile=self.links_file,\n        table=LinksConstants(),\n        url_col=url_col,\n    )\n\n    self.shared_content_table = BaseTable(\n        sqlite_connection=self.connection,\n        infile=shared_content_file,\n        outfile=self.shared_contents_file,\n        table=ShareContentConstants(),\n    )\n</code></pre>"},{"location":"reference/main/#minall.main.Minall.collect_and_coalesce","title":"<code>collect_and_coalesce()</code>","text":"<p>Collect new data and coalesce with existing data in relevant SQL tables.</p> <p>This method creates an instance of the class <code>Enrichment</code> (from <code>minall.enrichment.enrichment</code>), providing the target URL table ('links' table, <code>self.links_table</code>), the minet API credentials (<code>self.keys</code>), and the related shared content table (<code>self.shared_content_table</code>) which may go unused depending on parameters used when <code>Enrichment</code> is called.</p> <p>Having prepared the <code>Enrichment</code> instance, the method then calls the class, providing its <code>self.buzzsumo_only</code> instance attribute as the argument for <code>Enrichment</code>'s <code>buzzsumo_only</code> parameter. The latter boolean parameter determines whether all of the <code>Enrichment</code> class's methods will be deployed or only its Buzzsumo method.</p> Source code in <code>minall/main.py</code> <pre><code>def collect_and_coalesce(self):\n    \"\"\"Collect new data and coalesce with existing data in relevant SQL tables.\n\n    This method creates an instance of the class `Enrichment` (from `minall.enrichment.enrichment`), providing the target URL table ('links' table, `self.links_table`), the minet API credentials (`self.keys`), and the related shared content table (`self.shared_content_table`) which may go unused depending on parameters used when `Enrichment` is called.\n\n    Having prepared the `Enrichment` instance, the method then calls the class, providing its `self.buzzsumo_only` instance attribute as the argument for `Enrichment`'s `buzzsumo_only` parameter. The latter boolean parameter determines whether all of the `Enrichment` class's methods will be deployed or only its Buzzsumo method.\n    \"\"\"\n    enricher = Enrichment(\n        links_table=self.links_table,\n        shared_content_table=self.shared_content_table,\n        keys=self.keys,\n    )\n    enricher(buzzsumo_only=self.buzzsumo_only)\n</code></pre>"},{"location":"reference/main/#minall.main.Minall.export","title":"<code>export()</code>","text":"<p>Write enriched SQL tables to CSV out-files.</p> <p>This method simply exports to CSV files both of the <code>Minall</code> class instance's SQL tables, <code>self.links_table</code> and <code>self.shared_content_table</code>. The class that manages the SQL tables (<code>minall.tables.base.BaseTable</code>), stores each table's out-file path as an instance variable. The parent directory for both out-files was declared during <code>Minall</code>'s <code>__init__()</code> method via the parameter <code>output_dir</code>, from which the out-file paths were subsequently derived.</p> <p>Returns:</p> Type Description <code>Tuple[Path, Path]</code> <p>Tuple[Path, Path]: Paths to links and shared content CSV files.</p> Source code in <code>minall/main.py</code> <pre><code>def export(self) -&gt; Tuple[Path, Path]:\n    \"\"\"Write enriched SQL tables to CSV out-files.\n\n    This method simply exports to CSV files both of the `Minall` class instance's SQL tables, `self.links_table` and `self.shared_content_table`. The class that manages the SQL tables (`minall.tables.base.BaseTable`), stores each table's out-file path as an instance variable. The parent directory for both out-files was declared during `Minall`'s `__init__()` method via the parameter `output_dir`, from which the out-file paths were subsequently derived.\n\n    Returns:\n        Tuple[Path, Path]: Paths to links and shared content CSV files.\n    \"\"\"\n    self.links_table.export()\n    self.shared_content_table.export()\n    return self.links_file, self.shared_contents_file\n</code></pre>"},{"location":"reference/tables/","title":"Table tools","text":"<p>With SQLite, the module <code>minall/tables</code> manages the data during the enrichment process, from the data input at the start to the updated version exported at the end. The process relies on the following two tables:</p> <ol> <li> <p>The <code>links</code> table, which is the backbone of the enrichment, stores the target URLs and their enriched metadata.</p> </li> <li> <p>The <code>shared_content</code> table, which is optional, stores URLs pointing to content shared via the target URLs' content.</p> </li> </ol> <p>As illustrated in the figure below, the two tables are related. The target URL (<code>url</code>) in the <code>links</code> table refers to the <code>post_url</code> in the <code>shared_content</code> table. A target URL (<code>url</code>) in the <code>links</code> table can share 0 or more items. Depending on the URLs dataset, it could be the case that no entities in the <code>links</code> table have shared any content. All entities in the <code>shared_content</code> must relate to at least one entity in the <code>links</code> table. Content in the <code>shared_content</code> table can have been shared by 1 or more URLs in the <code>links</code> table.</p> <pre><code>erDiagram\n    LINKS }|--o{ SHARED_CONTENT : shares\n    LINKS {\n        text url PK\n        text domain\n        text work_type\n        text duration\n        text identifier\n        text date_published\n        text date_modified\n        text country_of_origin\n        text abstract\n        text keywords\n        text title\n        text text\n        text hashtags\n        text creator_type\n        text creator_date_created\n        text creator_identifier\n        integer creator_facebook_follow\n        integer creator_facebook_subscribe\n        integer creator_twitter_follow\n        integer creator_youtube_subscribe\n        integer creator_create_video\n        text creator_name\n        text creator_url\n        integer facebook_comment\n        integer facebook_like\n        integer facebook_share\n        integer pinterest_share\n        integer twitter_share\n        integer tiktok_share\n        integer tiktok_comment\n        integer reddit_engagement\n        integer youtube_watch\n        integer youtube_comment\n        integer youtube_like\n        integer youtube_favorite\n        integer youtube_subscribe\n        integer create_video\n    }\n    SHARED_CONTENT {\n        text post_url PK\n        text content_url PK\n        text media_type\n        integer height\n        integer width\n    }</code></pre>"},{"location":"reference/tables/#minall.tables.links","title":"<code>minall.tables.links</code>","text":""},{"location":"reference/tables/#minall.tables.links.constants","title":"<code>minall.tables.links.constants</code>","text":""},{"location":"reference/tables/#minall.tables.links.constants.LinksConstants","title":"<code>LinksConstants</code>  <code>dataclass</code>","text":"<p>Dataclass to manage 'links' table.</p> <p>This dataclass manages the 'links' table's required column names and their data types. Being a dataclass, however, the instance of the class can also be subsequently modified to include other column names (and their data types) according to the input data.</p> <p>For example, if the input dataset's target URL column has a name other than 'url,' such as the name 'cleaned_urls,' this dataclass's <code>dtypes</code> and <code>col_names</code> attributes can be modified to preserve the data file's additional column names. However, the column 'url' must indicate the target URLs. If the input dataset does not have a 'url' column, one will be created. If it already has a 'url' column, that will be parsed and treated as the target URL column.</p> <p>Attributes:</p> Name Type Description <code>table_name</code> <code>str</code> <p>Name of the table. Default = \"links\".</p> <code>primary_key</code> <code>str</code> <p>Text string of primary key. Default = \"url\".</p> <code>pk_list</code> <code>list</code> <p>List of primary key columns. Default = [\"url\"]</p> <code>dtypes</code> <code>dict</code> <p>Key-value pairs of column names and SQLite data type descriptions.</p> <code>col_names</code> <code>list</code> <p>List of column names.</p> Source code in <code>minall/tables/links/constants.py</code> <pre><code>@dataclass\nclass LinksConstants:\n    \"\"\"Dataclass to manage 'links' table.\n\n    This dataclass manages the 'links' table's required column names and their data types. Being a dataclass, however, the instance of the class can also be subsequently modified to include other column names (and their data types) according to the input data.\n\n    For example, if the input dataset's target URL column has a name other than 'url,' such as the name 'cleaned_urls,' this dataclass's `dtypes` and `col_names` attributes can be modified to preserve the data file's additional column names. However, the column 'url' must indicate the target URLs. If the input dataset does not have a 'url' column, one will be created. If it already has a 'url' column, that will be parsed and treated as the target URL column.\n\n    Attributes:\n        table_name (str): Name of the table. Default = \"links\".\n        primary_key (str): Text string of primary key. Default = \"url\".\n        pk_list (list): List of primary key columns. Default = [\"url\"]\n        dtypes (dict): Key-value pairs of column names and SQLite data type descriptions.\n        col_names (list): List of column names.\n    \"\"\"\n\n    table_name: str = \"links\"\n    primary_key: str = \"url\"\n    pk_list = [\"url\"]\n    dtypes = {\n        \"url\": \"TEXT\",\n        \"domain\": \"TEXT\",\n        \"work_type\": \"TEXT\",\n        \"duration\": \"TEXT\",\n        \"identifier\": \"TEXT\",\n        \"date_published\": \"TEXT\",\n        \"date_modified\": \"TEXT\",\n        \"country_of_origin\": \"TEXT\",\n        \"abstract\": \"TEXT\",\n        \"keywords\": \"TEXT\",\n        \"title\": \"TEXT\",\n        \"text\": \"TEXT\",\n        \"hashtags\": \"TEXT\",\n        \"creator_type\": \"TEXT\",\n        \"creator_date_created\": \"TEXT\",\n        \"creator_location_created\": \"TEXT\",\n        \"creator_identifier\": \"TEXT\",\n        \"creator_facebook_follow\": \"INTEGER\",\n        \"creator_facebook_subscribe\": \"INTEGER\",\n        \"creator_twitter_follow\": \"INTEGER\",\n        \"creator_youtube_subscribe\": \"INTEGER\",\n        \"creator_create_video\": \"INTEGER\",\n        \"creator_name\": \"TEXT\",\n        \"creator_url\": \"TEXT\",\n        \"facebook_comment\": \"INTEGER\",\n        \"facebook_like\": \"INTEGER\",\n        \"facebook_share\": \"INTEGER\",\n        \"pinterest_share\": \"INTEGER\",\n        \"twitter_share\": \"INTEGER\",\n        \"tiktok_share\": \"INTEGER\",\n        \"tiktok_comment\": \"INTEGER\",\n        \"reddit_engagement\": \"INTEGER\",\n        \"youtube_watch\": \"INTEGER\",\n        \"youtube_comment\": \"INTEGER\",\n        \"youtube_like\": \"INTEGER\",\n        \"youtube_favorite\": \"INTEGER\",\n        \"youtube_subscribe\": \"INTEGER\",\n        \"create_video\": \"INTEGER\",\n    }\n    col_names = dtypes.keys()\n</code></pre>"},{"location":"reference/tables/#minall.tables.shared_content","title":"<code>minall.tables.shared_content</code>","text":""},{"location":"reference/tables/#minall.tables.shared_content.constants","title":"<code>minall.tables.shared_content.constants</code>","text":""},{"location":"reference/tables/#minall.tables.shared_content.constants.ShareContentConstants","title":"<code>ShareContentConstants</code>  <code>dataclass</code>","text":"<p>Dataclass to manage 'shared_content' table.</p> <p>This dataclass manages the 'shared_content' table's required column names and their data types. Being a dataclass, however, the instance of the class can also be subsequently modified to include other column names (and their data types) according to the input data. The 'shared_content' table is meant to relate to the 'links' table, wherein the former's 'post_url' column refers to the latter's 'url' column.</p> <p>Contrary to the 'links' table, whose primary key column can be derived from any declared target URL column in the input data, the 'shared_content' table requires the input data has the two columns that jointly compose its primary key, 'post_url' and 'content_url.'</p> <p>Attributes:</p> Name Type Description <code>table_name</code> <code>str</code> <p>Name of the table. Default = \"shared_content\".</p> <code>primary_key</code> <code>str</code> <p>Text string of composite primary key. Default = \"post_url,content_url\".</p> <code>pk_list</code> <code>list</code> <p>List of comosite primary key columns. Default = [\"post_url\", \"content_url]</p> <code>dtypes</code> <code>dict</code> <p>Key-value pairs of column names and SQLite data type descriptions.</p> <code>col_names</code> <code>list</code> <p>List of column names.</p> Source code in <code>minall/tables/shared_content/constants.py</code> <pre><code>@dataclass\nclass ShareContentConstants:\n    \"\"\"Dataclass to manage 'shared_content' table.\n\n    This dataclass manages the 'shared_content' table's required column names and their data types. Being a dataclass, however, the instance of the class can also be subsequently modified to include other column names (and their data types) according to the input data. The 'shared_content' table is meant to relate to the 'links' table, wherein the former's 'post_url' column refers to the latter's 'url' column.\n\n    Contrary to the 'links' table, whose primary key column can be derived from any declared target URL column in the input data, the 'shared_content' table requires the input data has the two columns that jointly compose its primary key, 'post_url' and 'content_url.'\n\n    Attributes:\n        table_name (str): Name of the table. Default = \"shared_content\".\n        primary_key (str): Text string of composite primary key. Default = \"post_url,content_url\".\n        pk_list (list): List of comosite primary key columns. Default = [\"post_url\", \"content_url]\n        dtypes (dict): Key-value pairs of column names and SQLite data type descriptions.\n        col_names (list): List of column names.\n    \"\"\"\n\n    table_name = \"shared_content\"\n    primary_key = \"post_url,content_url\"\n    pk_list = [\"post_url\", \"content_url\"]\n    dtypes = {\n        \"post_url\": f\"TEXT REFERENCES {LinksConstants.table_name}(url) ON UPDATE CASCADE\",\n        \"media_type\": \"TEXT\",\n        \"content_url\": \"TEXT\",\n        \"height\": \"INTEGER\",\n        \"width\": \"INTEGER\",\n    }\n    col_names = dtypes.keys()\n</code></pre>"},{"location":"reference/tables/#minall.tables.base","title":"<code>minall.tables.base</code>","text":"<p>Create and execute queries on SQLite tables.</p> <p>This module contains the class <code>BaseTable</code> that manages the SQLite database's tables. It contains the following methods:</p> <ul> <li><code>__init__(sqlite_connection, infile, outfile, table, url_col)</code></li> <li><code>columns_to_update()</code></li> <li><code>coalesce(infile)</code></li> <li><code>export()</code></li> </ul>"},{"location":"reference/tables/#minall.tables.base.BaseTable","title":"<code>BaseTable</code>","text":"Source code in <code>minall/tables/base.py</code> <pre><code>class BaseTable:\n    def __init__(\n        self,\n        sqlite_connection: Connection,\n        infile: str | None,\n        outfile: Path,\n        table: LinksConstants | ShareContentConstants,\n        url_col: str | None = None,\n    ) -&gt; None:\n        \"\"\"_summary_\n\n        Args:\n            sqlite_connection (Connection): _description_\n            infile (str | None): _description_\n            outfile (Path): _description_\n            table (LinksConstants | ShareContentConstants): _description_\n            url_col (str | None, optional): _description_. Defaults to None.\n        \"\"\"\n        self.connection = sqlite_connection\n        self.executor = SQLiteWrapper(sqlite_connection)\n        self.outfile = outfile\n        self.table = table\n        self.columnparser = ColumnParser(\n            connection=self.connection,\n            table_constants=table,\n            infile=infile,\n            url_col=url_col,\n        )\n\n        # Create table upon creation of class instance\n        create_table(\n            connection=self.connection,\n            dtype_string=self.columnparser.infile_dtype_string,\n            table=self.table,\n        )\n\n        # Insert in-file data\n        insert_infile(\n            infile=infile,\n            standardized_columns=self.columnparser.infile_standardized,\n            connection=self.connection,\n            url_col=url_col,\n            table_name=self.table.table_name,\n        )\n\n    def columns_to_update(self) -&gt; str:\n        \"\"\"_summary_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        columns = []\n        for column in self.columnparser.infile_standardized:\n            if column not in self.table.pk_list:\n                columns.append(f\"{column}=COALESCE(excluded.{column}, {column})\")\n        return \", \".join(columns)\n\n    def coalesce(self, infile: Path):\n        \"\"\"_summary_\n\n        Args:\n            infile (Path): _description_\n        \"\"\"\n        table_columns = self.columnparser.infile_standardized\n        columns_to_update = self.columns_to_update()\n        with open(infile, \"r\") as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                values = parse_rows(infile_standardized=table_columns, row=row)\n                n_values = \", \".join([\"?\" for _ in range(len(values))])\n                query = f\"\"\"\n                INSERT INTO {self.table.table_name} ({\", \".join(table_columns)})\n                VALUES ({n_values})\n                ON CONFLICT ({self.table.primary_key})\n                DO UPDATE SET {columns_to_update}\n                \"\"\"\n                self.executor(query=query, values=values)  # type: ignore\n\n    def export(self):\n        \"\"\"_summary_\"\"\"\n        cursor = self.connection.cursor()\n        rows = cursor.execute(f\"SELECT * FROM {self.table.table_name}\").fetchall()\n        headers = self.columnparser.infile_standardized\n        with open(self.outfile, \"w\") as f:\n            writer = csv.writer(f)\n            writer.writerow(headers)\n            for row in rows:\n                writer.writerow(row)\n</code></pre>"},{"location":"reference/tables/#minall.tables.base.BaseTable.__init__","title":"<code>__init__(sqlite_connection, infile, outfile, table, url_col=None)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>sqlite_connection</code> <code>Connection</code> <p>description</p> required <code>infile</code> <code>str | None</code> <p>description</p> required <code>outfile</code> <code>Path</code> <p>description</p> required <code>table</code> <code>LinksConstants | ShareContentConstants</code> <p>description</p> required <code>url_col</code> <code>str | None</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>minall/tables/base.py</code> <pre><code>def __init__(\n    self,\n    sqlite_connection: Connection,\n    infile: str | None,\n    outfile: Path,\n    table: LinksConstants | ShareContentConstants,\n    url_col: str | None = None,\n) -&gt; None:\n    \"\"\"_summary_\n\n    Args:\n        sqlite_connection (Connection): _description_\n        infile (str | None): _description_\n        outfile (Path): _description_\n        table (LinksConstants | ShareContentConstants): _description_\n        url_col (str | None, optional): _description_. Defaults to None.\n    \"\"\"\n    self.connection = sqlite_connection\n    self.executor = SQLiteWrapper(sqlite_connection)\n    self.outfile = outfile\n    self.table = table\n    self.columnparser = ColumnParser(\n        connection=self.connection,\n        table_constants=table,\n        infile=infile,\n        url_col=url_col,\n    )\n\n    # Create table upon creation of class instance\n    create_table(\n        connection=self.connection,\n        dtype_string=self.columnparser.infile_dtype_string,\n        table=self.table,\n    )\n\n    # Insert in-file data\n    insert_infile(\n        infile=infile,\n        standardized_columns=self.columnparser.infile_standardized,\n        connection=self.connection,\n        url_col=url_col,\n        table_name=self.table.table_name,\n    )\n</code></pre>"},{"location":"reference/tables/#minall.tables.base.BaseTable.coalesce","title":"<code>coalesce(infile)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>infile</code> <code>Path</code> <p>description</p> required Source code in <code>minall/tables/base.py</code> <pre><code>def coalesce(self, infile: Path):\n    \"\"\"_summary_\n\n    Args:\n        infile (Path): _description_\n    \"\"\"\n    table_columns = self.columnparser.infile_standardized\n    columns_to_update = self.columns_to_update()\n    with open(infile, \"r\") as f:\n        reader = csv.DictReader(f)\n        for row in reader:\n            values = parse_rows(infile_standardized=table_columns, row=row)\n            n_values = \", \".join([\"?\" for _ in range(len(values))])\n            query = f\"\"\"\n            INSERT INTO {self.table.table_name} ({\", \".join(table_columns)})\n            VALUES ({n_values})\n            ON CONFLICT ({self.table.primary_key})\n            DO UPDATE SET {columns_to_update}\n            \"\"\"\n            self.executor(query=query, values=values)  # type: ignore\n</code></pre>"},{"location":"reference/tables/#minall.tables.base.BaseTable.columns_to_update","title":"<code>columns_to_update()</code>","text":"<p>summary</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>minall/tables/base.py</code> <pre><code>def columns_to_update(self) -&gt; str:\n    \"\"\"_summary_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    columns = []\n    for column in self.columnparser.infile_standardized:\n        if column not in self.table.pk_list:\n            columns.append(f\"{column}=COALESCE(excluded.{column}, {column})\")\n    return \", \".join(columns)\n</code></pre>"},{"location":"reference/tables/#minall.tables.base.BaseTable.export","title":"<code>export()</code>","text":"<p>summary</p> Source code in <code>minall/tables/base.py</code> <pre><code>def export(self):\n    \"\"\"_summary_\"\"\"\n    cursor = self.connection.cursor()\n    rows = cursor.execute(f\"SELECT * FROM {self.table.table_name}\").fetchall()\n    headers = self.columnparser.infile_standardized\n    with open(self.outfile, \"w\") as f:\n        writer = csv.writer(f)\n        writer.writerow(headers)\n        for row in rows:\n            writer.writerow(row)\n</code></pre>"},{"location":"reference/tables/#minall.tables.utils","title":"<code>minall.tables.utils</code>","text":"<p>Something.</p> <p>This module contains helper functions and methods used by the SQLite tables.</p>"},{"location":"reference/tables/#minall.tables.utils.ColumnParser","title":"<code>ColumnParser</code>  <code>dataclass</code>","text":"<p>summary</p> <p>Attributes:</p> Name Type Description <code>infile_dtype_string</code> <code>str</code> <p>something</p> <code>infile_original</code> <code>List[str]</code> <p>something</p> <code>infile_standardized</code> <code>List[str]</code> <p>something</p> <code>infile_dtypes</code> <code>Dict</code> <p>something</p> Source code in <code>minall/tables/utils.py</code> <pre><code>@dataclass\nclass ColumnParser:\n    \"\"\"_summary_\n\n    Attributes:\n        infile_dtype_string (str): __something__\n        infile_original (List[str]): __something__\n        infile_standardized (List[str]): __something__\n        infile_dtypes (Dict): __something__\n    \"\"\"\n\n    infile_dtype_string: str\n    infile_original: List[str] = field(default_factory=List)\n    infile_standardized: List[str] = field(default_factory=List)\n    infile_dtypes: Dict = field(default_factory=Dict)\n\n    def __init__(\n        self,\n        connection: Connection,\n        table_constants: LinksConstants | ShareContentConstants,\n        infile: str | None,\n        url_col: str | None,\n    ):\n        \"\"\"_summary_\n\n        Args:\n            connection (Connection): _description_\n            table_constants (LinksConstants | ShareContentConstants): _description_\n            infile (str | None): _description_\n            url_col (str | None): _description_\n        \"\"\"\n        self.connection = connection\n        self.infile = infile\n        self.url_col = url_col\n        self.table = table_constants\n\n        self.infile_original = self.parse_original_infile_columns()\n        self.infile_standardized = self.standardize_infile_columns()\n        self.infile_dtype = self.set_infile_column_dtypes()\n        self.infile_dtype_string = \", \".join(\n            [f\"{col} {dtype}\" for col, dtype in self.infile_dtype.items()]\n        )\n\n    def parse_original_infile_columns(self) -&gt; List[str]:\n        \"\"\"_summary_\n\n        Raises:\n            e: _description_\n\n        Returns:\n            List[str]: _description_\n        \"\"\"\n        columns = list(self.table.col_names)\n        if self.infile:\n            try:\n                columns = check_csv_headers(\n                    self.table.table_name, self.infile, self.url_col\n                )\n            except Exception as e:\n                raise e\n        return columns\n\n    def standardize_infile_columns(self) -&gt; List[str]:\n        \"\"\"_summary_\n\n        Returns:\n            List[str]: _description_\n        \"\"\"\n        # Copy all the columns from the in-file\n        standardized_infile_headers = self.infile_original.copy()\n        # If missing, add standardized columns to the list of in-file's columns\n        for standard_column_name in self.table.col_names:\n            if standard_column_name not in self.infile_original:\n                standardized_infile_headers.append(standard_column_name)\n        return standardized_infile_headers\n\n    def set_infile_column_dtypes(self) -&gt; dict:\n        \"\"\"_summary_\n\n        Returns:\n            dict: _description_\n        \"\"\"\n        dtypes = {}\n        for col_name in self.infile_standardized:\n            if not self.table.dtypes.get(col_name):\n                dtypes.update({col_name: \"TEXT\"})\n            else:\n                dtypes.update({col_name: self.table.dtypes[col_name]})\n        return dtypes\n</code></pre>"},{"location":"reference/tables/#minall.tables.utils.ColumnParser.__init__","title":"<code>__init__(connection, table_constants, infile, url_col)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>description</p> required <code>table_constants</code> <code>LinksConstants | ShareContentConstants</code> <p>description</p> required <code>infile</code> <code>str | None</code> <p>description</p> required <code>url_col</code> <code>str | None</code> <p>description</p> required Source code in <code>minall/tables/utils.py</code> <pre><code>def __init__(\n    self,\n    connection: Connection,\n    table_constants: LinksConstants | ShareContentConstants,\n    infile: str | None,\n    url_col: str | None,\n):\n    \"\"\"_summary_\n\n    Args:\n        connection (Connection): _description_\n        table_constants (LinksConstants | ShareContentConstants): _description_\n        infile (str | None): _description_\n        url_col (str | None): _description_\n    \"\"\"\n    self.connection = connection\n    self.infile = infile\n    self.url_col = url_col\n    self.table = table_constants\n\n    self.infile_original = self.parse_original_infile_columns()\n    self.infile_standardized = self.standardize_infile_columns()\n    self.infile_dtype = self.set_infile_column_dtypes()\n    self.infile_dtype_string = \", \".join(\n        [f\"{col} {dtype}\" for col, dtype in self.infile_dtype.items()]\n    )\n</code></pre>"},{"location":"reference/tables/#minall.tables.utils.ColumnParser.parse_original_infile_columns","title":"<code>parse_original_infile_columns()</code>","text":"<p>summary</p> <p>Raises:</p> Type Description <code>e</code> <p>description</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: description</p> Source code in <code>minall/tables/utils.py</code> <pre><code>def parse_original_infile_columns(self) -&gt; List[str]:\n    \"\"\"_summary_\n\n    Raises:\n        e: _description_\n\n    Returns:\n        List[str]: _description_\n    \"\"\"\n    columns = list(self.table.col_names)\n    if self.infile:\n        try:\n            columns = check_csv_headers(\n                self.table.table_name, self.infile, self.url_col\n            )\n        except Exception as e:\n            raise e\n    return columns\n</code></pre>"},{"location":"reference/tables/#minall.tables.utils.ColumnParser.set_infile_column_dtypes","title":"<code>set_infile_column_dtypes()</code>","text":"<p>summary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>description</p> Source code in <code>minall/tables/utils.py</code> <pre><code>def set_infile_column_dtypes(self) -&gt; dict:\n    \"\"\"_summary_\n\n    Returns:\n        dict: _description_\n    \"\"\"\n    dtypes = {}\n    for col_name in self.infile_standardized:\n        if not self.table.dtypes.get(col_name):\n            dtypes.update({col_name: \"TEXT\"})\n        else:\n            dtypes.update({col_name: self.table.dtypes[col_name]})\n    return dtypes\n</code></pre>"},{"location":"reference/tables/#minall.tables.utils.ColumnParser.standardize_infile_columns","title":"<code>standardize_infile_columns()</code>","text":"<p>summary</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: description</p> Source code in <code>minall/tables/utils.py</code> <pre><code>def standardize_infile_columns(self) -&gt; List[str]:\n    \"\"\"_summary_\n\n    Returns:\n        List[str]: _description_\n    \"\"\"\n    # Copy all the columns from the in-file\n    standardized_infile_headers = self.infile_original.copy()\n    # If missing, add standardized columns to the list of in-file's columns\n    for standard_column_name in self.table.col_names:\n        if standard_column_name not in self.infile_original:\n            standardized_infile_headers.append(standard_column_name)\n    return standardized_infile_headers\n</code></pre>"},{"location":"reference/tables/#minall.tables.utils.check_csv_headers","title":"<code>check_csv_headers(table_name, infile_path, url_col)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>description</p> required <code>infile_path</code> <code>str</code> <p>description</p> required <code>url_col</code> <code>str | None</code> <p>description</p> required <p>Raises:</p> Type Description <code>NoCSVHeaders</code> <p>description</p> <code>NoURLColumn</code> <p>description</p> <code>NoPrimaryKeyColumns</code> <p>description</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: description</p> Source code in <code>minall/tables/utils.py</code> <pre><code>def check_csv_headers(\n    table_name: str, infile_path: str, url_col: str | None\n) -&gt; List[str]:\n    \"\"\"_summary_\n\n    Args:\n        table_name (str): _description_\n        infile_path (str): _description_\n        url_col (str | None): _description_\n\n    Raises:\n        NoCSVHeaders: _description_\n        NoURLColumn: _description_\n        NoPrimaryKeyColumns: _description_\n\n    Returns:\n        List[str]: _description_\n    \"\"\"\n    with casanova.reader(infile_path) as reader:\n        columns = reader.fieldnames\n\n    if not isinstance(columns, List):\n        raise NoCSVHeaders()\n\n    if table_name == \"links\":\n        if url_col not in columns:\n            raise NoURLColumn(str(url_col))\n\n    elif table_name == \"shared_content\":\n        if \"post_url\" not in columns:\n            raise NoPrimaryKeyColumns(\"post_url\")\n        if \"content_url\" not in columns:\n            raise NoPrimaryKeyColumns(\"content_url\")\n    return columns\n</code></pre>"},{"location":"reference/tables/#minall.tables.utils.insert_infile","title":"<code>insert_infile(infile, standardized_columns, connection, table_name, url_col=None)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>infile</code> <code>str | None</code> <p>description</p> required <code>standardized_columns</code> <code>list</code> <p>description</p> required <code>connection</code> <code>Connection</code> <p>description</p> required <code>table_name</code> <code>str</code> <p>description</p> required <code>url_col</code> <code>str | None</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>minall/tables/utils.py</code> <pre><code>def insert_infile(\n    infile: str | None,\n    standardized_columns: list,\n    connection: Connection,\n    table_name: str,\n    url_col: str | None = None,\n):\n    \"\"\"_summary_\n\n    Args:\n        infile (str | None): _description_\n        standardized_columns (list): _description_\n        connection (Connection): _description_\n        table_name (str): _description_\n        url_col (str | None, optional): _description_. Defaults to None.\n    \"\"\"\n    if not infile:\n        pass\n    else:\n        executor = SQLiteWrapper(connection=connection)\n        with open(infile) as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                values = parse_rows(\n                    row=row,\n                    infile_standardized=standardized_columns,\n                    url_col=url_col,\n                )\n                n_values = \", \".join([\"?\" for _ in range(len(values))])\n                query = f\"\"\"\n                INSERT OR IGNORE INTO {table_name} ({\", \".join(standardized_columns)})\n                VALUES ({n_values})\n                \"\"\"\n                executor(query=query, values=values)  # type: ignore\n</code></pre>"},{"location":"reference/tables/#minall.tables.utils.parse_rows","title":"<code>parse_rows(infile_standardized, row, url_col=None)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>infile_standardized</code> <code>List</code> <p>description</p> required <code>row</code> <code>Dict</code> <p>description</p> required <code>url_col</code> <code>str | None</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>description</p> Source code in <code>minall/tables/utils.py</code> <pre><code>def parse_rows(\n    infile_standardized: List, row: Dict, url_col: str | None = None\n) -&gt; tuple:\n    \"\"\"_summary_\n\n    Args:\n        infile_standardized (List): _description_\n        row (Dict): _description_\n        url_col (str | None, optional): _description_. Defaults to None.\n\n    Returns:\n        tuple: _description_\n    \"\"\"\n    values = []\n    for col in infile_standardized:\n        if col == \"url\" and url_col:\n            values.append(row[url_col])\n        elif row.get(col):\n            values.append(row[col])\n        else:\n            values.append(None)\n    return tuple(values)\n</code></pre>"},{"location":"reference/tables/#minall.tables.exceptions","title":"<code>minall.tables.exceptions</code>","text":"<p>Exceptions for validating CSV files used to create SQLite tables.</p> <p>This module contains exceptions to manage the process of validating a CSV file given as input for the enrichment process. The module contains the following exceptions:</p> <ul> <li><code>NoCSVHeaders</code> - The CSV does not have headers.</li> <li><code>NoURLColumn</code> - When building the 'links' table, the declared URL column is not in the CSV file.</li> <li><code>NoPrimaryKeyColumns</code> - When building the 'shared_content' table, either the 'post_url' column or the 'content_url' column are missing from the CSV file.</li> </ul> <p>When creating the 'links' table, the input CSV file must have a column for URLs; the URLs must be cleaned and/or ready to serve as the source for the data collection. The name of the URL column can vary and must be declared.</p> <p>When creating the 'shared_content' table, the column names are not modifiable. The CSV must have the columns 'post_url' and 'content_url;' the former relates to a URL in the 'links' table, and the latter incidates a URL for content embedded in the Web Content of the former.</p>"},{"location":"reference/tables/#minall.tables.exceptions.NoCSVHeaders","title":"<code>NoCSVHeaders</code>","text":"<p>             Bases: <code>Exception</code></p> <p>The CSV in-file lacks headers.</p> Source code in <code>minall/tables/exceptions.py</code> <pre><code>class NoCSVHeaders(Exception):\n    \"\"\"The CSV in-file lacks headers.\"\"\"\n\n    def __init__(self) -&gt; None:\n        message = \"No headers detected in CSV file.\"\n        super().__init__(message)\n</code></pre>"},{"location":"reference/tables/#minall.tables.exceptions.NoPrimaryKeyColumns","title":"<code>NoPrimaryKeyColumns</code>","text":"<p>             Bases: <code>Exception</code></p> <p>The CSV in-file is missing a required column.</p> Source code in <code>minall/tables/exceptions.py</code> <pre><code>class NoPrimaryKeyColumns(Exception):\n    \"\"\"The CSV in-file is missing a required column.\"\"\"\n\n    def __init__(self, col: str) -&gt; None:\n        message = f\"Required primary key column '{col}' is not a header in the given CSV file.\"\n        super().__init__(message)\n</code></pre>"},{"location":"reference/tables/#minall.tables.exceptions.NoURLColumn","title":"<code>NoURLColumn</code>","text":"<p>             Bases: <code>Exception</code></p> <p>The CSV in-file is missing a user-declared column.</p> Source code in <code>minall/tables/exceptions.py</code> <pre><code>class NoURLColumn(Exception):\n    \"\"\"The CSV in-file is missing a user-declared column.\"\"\"\n\n    def __init__(self, url_col: str) -&gt; None:\n        message = f\"The declared URL column '{url_col}' is not a header in the given CSV file.\"\n        super().__init__(message)\n</code></pre>"},{"location":"reference/utils/","title":"Utilities","text":"<p>Little blurb</p>"},{"location":"reference/utils/#minall.utils.database","title":"<code>minall.utils.database</code>","text":"<p>Utilities to manage SQLite database connection.</p> <p>The module contains the following function and class:</p> <ul> <li><code>connect_to_database(database)</code> - If provided with path, connects to embedded SQLite database; otherwise, connects to in-memory SQLite database.</li> <li><code>SQLiteWrapper(connection)</code> - Stores connection and cursor, executes queries.</li> </ul>"},{"location":"reference/utils/#minall.utils.database.SQLiteWrapper","title":"<code>SQLiteWrapper</code>","text":"<p>Class to store SQLite database connection and execute SQL queries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n&gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n&gt;&gt;&gt; wrapper.select(\"select * from test\")\n[]\n</code></pre> Source code in <code>minall/utils/database.py</code> <pre><code>class SQLiteWrapper:\n    \"\"\"Class to store SQLite database connection and execute SQL queries.\n\n    Examples:\n        &gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n        &gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n        &gt;&gt;&gt; wrapper.select(\"select * from test\")\n        []\n\n    \"\"\"\n\n    def __init__(self, connection: Connection) -&gt; None:\n        \"\"\"Store database connection and create cursor.\n\n        Examples:\n            &gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n            &gt;&gt;&gt; type(wrapper.cursor)\n            &lt;class 'sqlite3.Cursor'&gt;\n\n        Args:\n            connection (Connection): Connection to SQLite database.\n        \"\"\"\n        self.connection = connection\n        self.cursor = self.connection.cursor()\n\n    def __call__(self, query: str, values: List[Tuple] | None = None) -&gt; None:\n        \"\"\"Execute and commit SQL query.\n\n        Examples:\n            &gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n            &gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n            &gt;&gt;&gt; wrapper.select(\"select * from test\")\n            []\n\n        Args:\n            query (str): Query string, can contain SQL place holders for values (?).\n            values (list[tuple] | None, optional): Values to be included in query. Defaults to None.\n\n        Raises:\n            Exception: `sqlite3` Exception caused either by falling to execute query with cursor or by failing to commit changes to connected database.\n        \"\"\"\n        try:\n            if values:\n                self.cursor.execute(query, values)\n            else:\n                self.cursor.execute(query)\n            self.connection.commit()\n        except Exception as e:\n            print(\"\\n\", query, \"\\n\")\n            print(values)\n            raise e\n\n    def select(self, query: str) -&gt; List:\n        \"\"\"Return selection from SQLite database.\n\n        Examples:\n            &gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n            &gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n            &gt;&gt;&gt; wrapper.select(\"select * from test\")\n            []\n\n        Args:\n            query (str): SQL select query.\n\n        Raises:\n            Exception: `sqlite3` Exception caused either by falling to execute query with cursor or by failing to commit changes to connected database.\n\n        Returns:\n            List: Array of results from SQL query.\n        \"\"\"\n        try:\n            response = self.cursor.execute(query)\n            self.connection.commit()\n        except Exception as e:\n            print(\"\\n\", query, \"\\n\")\n            raise e\n        else:\n            return response.fetchall()\n</code></pre>"},{"location":"reference/utils/#minall.utils.database.SQLiteWrapper.__call__","title":"<code>__call__(query, values=None)</code>","text":"<p>Execute and commit SQL query.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n&gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n&gt;&gt;&gt; wrapper.select(\"select * from test\")\n[]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Query string, can contain SQL place holders for values (?).</p> required <code>values</code> <code>list[tuple] | None</code> <p>Values to be included in query. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p><code>sqlite3</code> Exception caused either by falling to execute query with cursor or by failing to commit changes to connected database.</p> Source code in <code>minall/utils/database.py</code> <pre><code>def __call__(self, query: str, values: List[Tuple] | None = None) -&gt; None:\n    \"\"\"Execute and commit SQL query.\n\n    Examples:\n        &gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n        &gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n        &gt;&gt;&gt; wrapper.select(\"select * from test\")\n        []\n\n    Args:\n        query (str): Query string, can contain SQL place holders for values (?).\n        values (list[tuple] | None, optional): Values to be included in query. Defaults to None.\n\n    Raises:\n        Exception: `sqlite3` Exception caused either by falling to execute query with cursor or by failing to commit changes to connected database.\n    \"\"\"\n    try:\n        if values:\n            self.cursor.execute(query, values)\n        else:\n            self.cursor.execute(query)\n        self.connection.commit()\n    except Exception as e:\n        print(\"\\n\", query, \"\\n\")\n        print(values)\n        raise e\n</code></pre>"},{"location":"reference/utils/#minall.utils.database.SQLiteWrapper.__init__","title":"<code>__init__(connection)</code>","text":"<p>Store database connection and create cursor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n&gt;&gt;&gt; type(wrapper.cursor)\n&lt;class 'sqlite3.Cursor'&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>Connection to SQLite database.</p> required Source code in <code>minall/utils/database.py</code> <pre><code>def __init__(self, connection: Connection) -&gt; None:\n    \"\"\"Store database connection and create cursor.\n\n    Examples:\n        &gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n        &gt;&gt;&gt; type(wrapper.cursor)\n        &lt;class 'sqlite3.Cursor'&gt;\n\n    Args:\n        connection (Connection): Connection to SQLite database.\n    \"\"\"\n    self.connection = connection\n    self.cursor = self.connection.cursor()\n</code></pre>"},{"location":"reference/utils/#minall.utils.database.SQLiteWrapper.select","title":"<code>select(query)</code>","text":"<p>Return selection from SQLite database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n&gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n&gt;&gt;&gt; wrapper.select(\"select * from test\")\n[]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>SQL select query.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p><code>sqlite3</code> Exception caused either by falling to execute query with cursor or by failing to commit changes to connected database.</p> <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>Array of results from SQL query.</p> Source code in <code>minall/utils/database.py</code> <pre><code>def select(self, query: str) -&gt; List:\n    \"\"\"Return selection from SQLite database.\n\n    Examples:\n        &gt;&gt;&gt; wrapper = SQLiteWrapper(connection=connect_to_database())\n        &gt;&gt;&gt; _ = wrapper(query=\"create table test(name text)\")\n        &gt;&gt;&gt; wrapper.select(\"select * from test\")\n        []\n\n    Args:\n        query (str): SQL select query.\n\n    Raises:\n        Exception: `sqlite3` Exception caused either by falling to execute query with cursor or by failing to commit changes to connected database.\n\n    Returns:\n        List: Array of results from SQL query.\n    \"\"\"\n    try:\n        response = self.cursor.execute(query)\n        self.connection.commit()\n    except Exception as e:\n        print(\"\\n\", query, \"\\n\")\n        raise e\n    else:\n        return response.fetchall()\n</code></pre>"},{"location":"reference/utils/#minall.utils.database.connect_to_database","title":"<code>connect_to_database(database=None)</code>","text":"<p>Connect to SQLite database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; conn = connect_to_database()\n&gt;&gt;&gt; type(conn)\n&lt;class 'sqlite3.Connection'&gt;\n&gt;&gt;&gt; _ = conn.cursor().execute(\"create table test(name text)\")\n&gt;&gt;&gt; conn.cursor().execute(\"select * from test\").fetchall()\n[]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>str | None</code> <p>If given, path to embedded SQLite database. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Connection</code> <code>Connection</code> <p>description</p> Source code in <code>minall/utils/database.py</code> <pre><code>def connect_to_database(database: str | None = None) -&gt; Connection:\n    \"\"\"Connect to SQLite database.\n\n    Examples:\n        &gt;&gt;&gt; conn = connect_to_database()\n        &gt;&gt;&gt; type(conn)\n        &lt;class 'sqlite3.Connection'&gt;\n        &gt;&gt;&gt; _ = conn.cursor().execute(\"create table test(name text)\")\n        &gt;&gt;&gt; conn.cursor().execute(\"select * from test\").fetchall()\n        []\n\n    Args:\n        database (str | None, optional): If given, path to embedded SQLite database. Defaults to None.\n\n    Returns:\n        Connection: _description_\n    \"\"\"\n\n    if database:\n        [p.mkdir(exist_ok=True) for p in Path(database).parents]\n        connection = sqlite3.connect(database)\n    else:\n        connection = sqlite3.connect(\":memory:\")\n    return connection\n</code></pre>"},{"location":"reference/utils/#minall.utils.parse_config","title":"<code>minall.utils.parse_config</code>","text":"<p>Data class to store and manage minet client credentials.</p> <p>The class <code>APIKeys</code> contains the following methods and properties:</p> <ul> <li><code>__init__(config)</code> - Parses the minet client configuration details.</li> <li><code>env_string()</code> - Formats the minet client credentials as an environment variable string.</li> <li><code>load_config_file(config_file)</code> - Parse client configuration details from JSON or YAML file.</li> </ul>"},{"location":"reference/utils/#minall.utils.parse_config.APIKeys","title":"<code>APIKeys</code>  <code>dataclass</code>","text":"<p>Data class to store and manage minet client credentials.</p> <p>Attributes:</p> Name Type Description <code>buzzsumo_token</code> <code>Optional[str]</code> <p>Buzzsumo API token. Optional.</p> <code>crowdtangle_token</code> <code>Optional[str]</code> <p>CrowdTangle API token. Optional.</p> <code>crowdtangle_rate_limit</code> <code>Optional[str]</code> <p>CrowdTangle API rate limit, cast as a string. Optional.</p> <code>youtube_key</code> <code>Optional[List[str]]) </code> <p>List of YouTube API keys. Optional.</p> Source code in <code>minall/utils/parse_config.py</code> <pre><code>@dataclass\nclass APIKeys:\n    \"\"\"Data class to store and manage minet client credentials.\n\n    Attributes:\n        buzzsumo_token (Optional[str]): Buzzsumo API token. Optional.\n        crowdtangle_token (Optional[str]):  CrowdTangle API token. Optional.\n        crowdtangle_rate_limit (Optional[str]): CrowdTangle API rate limit, cast as a string. Optional.\n        youtube_key (Optional[List[str]]) : List of YouTube API keys. Optional.\n    \"\"\"\n\n    buzzsumo_token: Optional[str]\n    crowdtangle_token: Optional[str]\n    crowdtangle_rate_limit: Optional[str]\n    youtube_key: Optional[List[str]]\n\n    def __init__(self, config: str | dict | None = None):\n        \"\"\"Parse and save minet API client configuration details.\n\n        Examples:\n            &gt;&gt;&gt; keys = APIKeys(config={\"youtube\": {\"key\": \"key1,key2\"}})\n            &gt;&gt;&gt; keys\n            APIKeys(buzzsumo_token=None, crowdtangle_token=None, crowdtangle_rate_limit=None, youtube_key=[\"key1\", \"key2\"])\n            &gt;&gt;&gt; keys.youtube_key\n            [\"key1, \"key2]\n\n        Args:\n            config (str | dict | None, optional): If string, string is treated like file path to JSON or YAML file that contains details; if dict, details are directly parsed; if None, details are searched from environment variables. Defaults to None.\n        \"\"\"\n        if config:\n            if isinstance(config, str):\n                parsed_config = self.load_config_file(config)\n            else:\n                parsed_config = config\n            self.buzzsumo_token = parsed_config[\"buzzsumo\"][\"token\"]\n            self.crowdtangle_token = parsed_config[\"crowdtangle\"][\"token\"]\n            self.crowdtangle_rate_limit = parsed_config[\"crowdtangle\"][\"rate_limit\"]\n            yt_keys = parsed_config[\"youtube\"][\"key\"]\n            if isinstance(yt_keys, list):\n                self.youtube_key = yt_keys\n            else:\n                self.youtube_key = parsed_config[\"youtube\"][\"key\"].split(\",\")\n        else:\n            self.buzzsumo_token = os.environ.get(\"BUZZSUMO_TOKEN\")\n            self.crowdtangle_token = os.environ.get(\"CROWDTANGLE_TOKEN\")\n            self.crowdtangle_rate_limit = os.environ.get(\"CROWDTANGLE_RATE_LIMIT\")\n            youtube_key = os.environ.get(\"YOUTUBE_KEY\")\n            if youtube_key:\n                self.youtube_key = youtube_key.split(\",\")\n            else:\n                self.youtube_key = []\n\n    @property\n    def env_string(self) -&gt; str:\n        r\"\"\"Formatted string for setting environment variables.\n\n        Examples:\n            &gt;&gt;&gt; keys = APIKeys(config={'buzzsumo': {'token': 'bz_token'}, 'crowdtangle': {'token': 'ct_token', 'rate_limit': 10}, 'youtube': {'key': 'key1,key2'}})\n            &gt;&gt;&gt; keys.env_string\n            \"BUZZSUMO_TOKEN=bz_token\\nCROWDTANGLE_TOKEN=ct_token\\nCROWDTANGLE_RATE_LIMIT=10\\nYOUTUBE_KEY=['key1', 'key2']\\n\"\n\n        Returns:\n            str: String declaring environment variables.\n        \"\"\"\n\n        return \"BUZZSUMO_TOKEN={bz}\\nCROWDTANGLE_TOKEN={ct}\\nCROWDTANGLE_RATE_LIMIT={crl}\\nYOUTUBE_KEY={yt}\\n\".format(\n            bz=self.buzzsumo_token,\n            ct=self.crowdtangle_token,\n            crl=self.crowdtangle_rate_limit,\n            yt=self.youtube_key,\n        )\n\n    def load_config_file(self, config_file: str) -&gt; dict:\n        \"\"\"Parse dictionary from JSON or YAML configuration file.\n\n        Args:\n            config_file (str): Path to JSON or YAML file.\n\n        Raises:\n            OSError: Error raised if given file path does not have the extension \".json\", \".yml\", or \".yaml\".\n\n        Returns:\n            dict: Parsed dictionary from JSON or YAML configuration file.\n        \"\"\"\n\n        with open(config_file) as f:\n            extension = Path(config_file).suffix\n            if extension == \".json\":\n                return json.load(f)\n            elif extension == \".yml\" or extension == \".yaml\":\n                return yaml.safe_load(f)\n            else:\n                raise OSError\n</code></pre>"},{"location":"reference/utils/#minall.utils.parse_config.APIKeys.env_string","title":"<code>env_string: str</code>  <code>property</code>","text":"<p>Formatted string for setting environment variables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; keys = APIKeys(config={'buzzsumo': {'token': 'bz_token'}, 'crowdtangle': {'token': 'ct_token', 'rate_limit': 10}, 'youtube': {'key': 'key1,key2'}})\n&gt;&gt;&gt; keys.env_string\n\"BUZZSUMO_TOKEN=bz_token\\nCROWDTANGLE_TOKEN=ct_token\\nCROWDTANGLE_RATE_LIMIT=10\\nYOUTUBE_KEY=['key1', 'key2']\\n\"\n</code></pre> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String declaring environment variables.</p>"},{"location":"reference/utils/#minall.utils.parse_config.APIKeys.__init__","title":"<code>__init__(config=None)</code>","text":"<p>Parse and save minet API client configuration details.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; keys = APIKeys(config={\"youtube\": {\"key\": \"key1,key2\"}})\n&gt;&gt;&gt; keys\nAPIKeys(buzzsumo_token=None, crowdtangle_token=None, crowdtangle_rate_limit=None, youtube_key=[\"key1\", \"key2\"])\n&gt;&gt;&gt; keys.youtube_key\n[\"key1, \"key2]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str | dict | None</code> <p>If string, string is treated like file path to JSON or YAML file that contains details; if dict, details are directly parsed; if None, details are searched from environment variables. Defaults to None.</p> <code>None</code> Source code in <code>minall/utils/parse_config.py</code> <pre><code>def __init__(self, config: str | dict | None = None):\n    \"\"\"Parse and save minet API client configuration details.\n\n    Examples:\n        &gt;&gt;&gt; keys = APIKeys(config={\"youtube\": {\"key\": \"key1,key2\"}})\n        &gt;&gt;&gt; keys\n        APIKeys(buzzsumo_token=None, crowdtangle_token=None, crowdtangle_rate_limit=None, youtube_key=[\"key1\", \"key2\"])\n        &gt;&gt;&gt; keys.youtube_key\n        [\"key1, \"key2]\n\n    Args:\n        config (str | dict | None, optional): If string, string is treated like file path to JSON or YAML file that contains details; if dict, details are directly parsed; if None, details are searched from environment variables. Defaults to None.\n    \"\"\"\n    if config:\n        if isinstance(config, str):\n            parsed_config = self.load_config_file(config)\n        else:\n            parsed_config = config\n        self.buzzsumo_token = parsed_config[\"buzzsumo\"][\"token\"]\n        self.crowdtangle_token = parsed_config[\"crowdtangle\"][\"token\"]\n        self.crowdtangle_rate_limit = parsed_config[\"crowdtangle\"][\"rate_limit\"]\n        yt_keys = parsed_config[\"youtube\"][\"key\"]\n        if isinstance(yt_keys, list):\n            self.youtube_key = yt_keys\n        else:\n            self.youtube_key = parsed_config[\"youtube\"][\"key\"].split(\",\")\n    else:\n        self.buzzsumo_token = os.environ.get(\"BUZZSUMO_TOKEN\")\n        self.crowdtangle_token = os.environ.get(\"CROWDTANGLE_TOKEN\")\n        self.crowdtangle_rate_limit = os.environ.get(\"CROWDTANGLE_RATE_LIMIT\")\n        youtube_key = os.environ.get(\"YOUTUBE_KEY\")\n        if youtube_key:\n            self.youtube_key = youtube_key.split(\",\")\n        else:\n            self.youtube_key = []\n</code></pre>"},{"location":"reference/utils/#minall.utils.parse_config.APIKeys.load_config_file","title":"<code>load_config_file(config_file)</code>","text":"<p>Parse dictionary from JSON or YAML configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to JSON or YAML file.</p> required <p>Raises:</p> Type Description <code>OSError</code> <p>Error raised if given file path does not have the extension \".json\", \".yml\", or \".yaml\".</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Parsed dictionary from JSON or YAML configuration file.</p> Source code in <code>minall/utils/parse_config.py</code> <pre><code>def load_config_file(self, config_file: str) -&gt; dict:\n    \"\"\"Parse dictionary from JSON or YAML configuration file.\n\n    Args:\n        config_file (str): Path to JSON or YAML file.\n\n    Raises:\n        OSError: Error raised if given file path does not have the extension \".json\", \".yml\", or \".yaml\".\n\n    Returns:\n        dict: Parsed dictionary from JSON or YAML configuration file.\n    \"\"\"\n\n    with open(config_file) as f:\n        extension = Path(config_file).suffix\n        if extension == \".json\":\n            return json.load(f)\n        elif extension == \".yml\" or extension == \".yaml\":\n            return yaml.safe_load(f)\n        else:\n            raise OSError\n</code></pre>"},{"location":"reference/utils/#minall.utils.progress_bar","title":"<code>minall.utils.progress_bar</code>","text":"<p>Context for rich progress bar.</p>"},{"location":"reference/utils/#minall.utils.progress_bar.progress_bar","title":"<code>progress_bar()</code>","text":"<p>Rich progress bar with Spinner column.</p> <p>Yields:</p> Type Description <code>Progress</code> <p>Generator[Progress, None, None]: Rich progress bar context</p> Source code in <code>minall/utils/progress_bar.py</code> <pre><code>@contextmanager\ndef progress_bar() -&gt; Generator[Progress, None, None]:\n    \"\"\"Rich progress bar with Spinner column.\n\n    Yields:\n        Generator[Progress, None, None]: Rich progress bar context\n    \"\"\"\n    with Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        SpinnerColumn(),\n        MofNCompleteColumn(),\n        TimeElapsedColumn(),\n    ) as progress:\n        yield progress\n</code></pre>"}]}